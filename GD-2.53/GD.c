/*
 * This file was generated automatically by ExtUtils::ParseXS version 3.28 from the
 * contents of GD.xs. Do not edit this file, edit GD.xs instead.
 *
 *    ANY CHANGES MADE HERE WILL BE LOST!
 *
 */

#line 1 "GD.xs"
#ifdef PERL_CAPI
#define WIN32IO_IS_STDIO
#endif
#include "EXTERN.h"
#include "perl.h"
#include "XSUB.h"
#include <gd.h>
#include <gdfontg.h>
#include <gdfontl.h>
#include <gdfontmb.h>
#include <gdfonts.h>
#include <gdfontt.h>
#include <errno.h>

#ifdef FCGI
 #include <fcgi_stdio.h>
#else
 #ifdef USE_SFIO
  #include <config.h>
 #else
  #include <stdio.h>
 #endif
 #include <perlio.h>
#endif
/* Copyright 1995 - 1998, Lincoln D. Stein.  See accompanying README file for
	usage restrictions */

#ifndef PERL_REVISION
#   ifndef __PATCHLEVEL_H_INCLUDED__
#       include "patchlevel.h"
#   endif
#   ifndef PERL_REVISION
#       define PERL_REVISION    (5)
        /* Replace: 1 */
#       define PERL_VERSION     PATCHLEVEL
#       define PERL_SUBVERSION  SUBVERSION
        /* Replace PERL_PATCHLEVEL with PERL_VERSION */
        /* Replace: 0 */
#   endif
#endif

#if (PERL_VERSION == 5) && (PERL_SUBVERSION==3)
#ifndef PL_na
# define PL_na na
#endif

#ifndef SvPV_nolen
# define SvPV_nolen(sv) SvPV(sv, PL_na)
#endif
#endif /* 5.00503 */

#ifdef WIN32
#define snprintf _snprintf
#endif

#ifndef START_MY_CXT
static truecolor_default = 0;
#endif

static int
not_here(char *s)
{
    croak("%s not implemented on this architecture", s);
    return -1;
}

static double
constant(char *name)
{
    errno = 0;
    switch (*name) {
    case 'A':
	break;
    case 'B':
	break;
    case 'C':
	break;
    case 'D':
	break;
    case 'E':
	break;
    case 'F':
	break;
    case 'G':
	if (strEQ(name, "GD_CMP_IMAGE"))
#ifdef GD_CMP_IMAGE
	  return GD_CMP_IMAGE;
#else
	    goto not_there;
#endif
	if (strEQ(name, "GD_CMP_NUM_COLORS"))
#ifdef GD_CMP_NUM_COLORS
	  return GD_CMP_NUM_COLORS;
#else
	goto not_there;
#endif
	if (strEQ(name, "GD_CMP_COLOR"))
#ifdef GD_CMP_COLOR
	  return GD_CMP_COLOR;
#else
	goto not_there;
#endif
	if (strEQ(name, "GD_CMP_SIZE_X"))
#ifdef GD_CMP_SIZE_X
	  return GD_CMP_SIZE_X;
#else
	goto not_there;
#endif
	if (strEQ(name, "GD_CMP_SIZE_Y"))
#ifdef GD_CMP_SIZE_Y
	  return GD_CMP_SIZE_Y;
#else
	goto not_there;
#endif
	if (strEQ(name, "GD_CMP_TRANSPARENT"))
#ifdef GD_CMP_TRANSPARENT
	  return GD_CMP_TRANSPARENT;
#else
	goto not_there;
#endif
	if (strEQ(name, "GD_CMP_BACKGROUND"))
#ifdef GD_CMP_BACKGROUND
	  return GD_CMP_BACKGROUND;
#else
	goto not_there;
#endif
	if (strEQ(name, "GD_CMP_INTERLACE"))
#ifdef GD_CMP_INTERLACE
	  return GD_CMP_INTERLACE;
#else
	goto not_there;
#endif
	if (strEQ(name, "GD_CMP_TRUECOLOR"))
#ifdef GD_CMP_TRUECOLOR
	  return GD_CMP_TRUECOLOR;
#else
	goto not_there;
#endif
	break;
    case 'H':
	break;
    case 'I':
	break;
    case 'J':
	break;
    case 'K':
	break;
    case 'L':
	break;
    case 'M':
	break;
    case 'N':
	break;
    case 'O':
	break;
    case 'P':
	break;
    case 'Q':
	break;
    case 'R':
	break;
    case 'S':
	break;
    case 'T':
	break;
    case 'U':
	break;
    case 'V':
	break;
    case 'W':
	break;
    case 'X':
	break;
    case 'Y':
	break;
    case 'Z':
	break;
    case 'a':
	break;
    case 'b':
	break;
    case 'c':
	break;
    case 'd':
	break;
    case 'e':
	break;
    case 'f':
	break;
    case 'g':
	if (strEQ(name, "gdBrushed"))
#ifdef gdBrushed
	    return gdBrushed;
#else
	    goto not_there;
#endif
	if (strEQ(name, "gdDashSize"))
#ifdef gdDashSize
	    return gdDashSize;
#else
	    goto not_there;
#endif
	if (strEQ(name, "gdMaxColors"))
#ifdef gdMaxColors
	    return gdMaxColors;
#else
	    goto not_there;
#endif
	if (strEQ(name, "gdStyled"))
#ifdef gdStyled
	    return gdStyled;
#else
	    goto not_there;
#endif
	if (strEQ(name, "gdStyledBrushed"))
#ifdef gdStyledBrushed
	    return gdStyledBrushed;
#else
	    goto not_there;
#endif
	if (strEQ(name, "gdTiled"))
#ifdef gdTiled
	    return gdTiled;
#else
	    goto not_there;
#endif
	if (strEQ(name, "gdTransparent"))
#ifdef gdTransparent
	    return gdTransparent;
#else
	    goto not_there;
#endif
        if (strEQ(name,"gdAntiAliased"))
#ifdef gdAntiAliased
	    return gdAntiAliased;
#else
	    goto not_there;
#endif
        if (strEQ(name,"gdAntiAliased"))
#ifdef gdAntiAliased
	    return gdAntiAliased;
#else
	    goto not_there;
#endif
        if (strEQ(name,"gdArc"))
#ifdef gdArc
	  return gdArc;
#else
	    goto not_there;
#endif
        if (strEQ(name,"gdPie"))
#ifdef gdPie
	  return gdPie;
#else
	    goto not_there;
#endif
        if (strEQ(name,"gdChord"))
#ifdef gdChord
	  return gdChord;
#else
	    goto not_there;
#endif
        if (strEQ(name,"gdNoFill"))
#ifdef gdNoFill
	  return gdNoFill;
#else
	    goto not_there;
#endif
        if (strEQ(name,"gdEdged"))
#ifdef gdEdged
	  return gdEdged;
#else
	    goto not_there;
#endif
		if (strEQ(name,"gdAlphaMax"))
#ifdef gdAlphaMax
		return gdAlphaMax;
#else
		goto not_there;
#endif
		if (strEQ(name,"gdAlphaOpaque"))
#ifdef gdAlphaOpaque
		return gdAlphaOpaque;
#else
		goto not_there;
#endif
		if (strEQ(name,"gdAlphaTransparent"))
#ifdef gdAlphaTransparent
		return gdAlphaTransparent;
#else
		goto not_there;
#endif

	break;
    case 'h':
	break;
    case 'i':
	break;
    case 'j':
	break;
    case 'k':
	break;
    case 'l':
	break;
    case 'm':
	break;
    case 'n':
	break;
    case 'o':
	break;
    case 'p':
	break;
    case 'q':
	break;
    case 'r':
	break;
    case 's':
	break;
    case 't':
	break;
    case 'u':
	break;
    case 'v':
	break;
    case 'w':
	break;
    case 'x':
	break;
    case 'y':
	break;
    case 'z':
	break;
    }
    errno = EINVAL;
    return 0;

not_there:
    errno = ENOENT;
    return 0;
}

typedef gdImagePtr	GD__Image;
typedef gdFontPtr	GD__Font;
typedef PerlIO          * InputStream;

#ifdef PERL_OBJECT
#  ifdef WIN32
#define GDIMAGECREATEFROMPNG(x)  gdImageCreateFromPng((FILE*)x)
#define GDIMAGECREATEFROMXBM(x)  gdImageCreateFromXbm((FILE*)x)
#define GDIMAGECREATEFROMJPEG(x) gdImageCreateFromJpeg((FILE*)x)
#define GDIMAGECREATEFROMGIF(x)  gdImageCreateFromGif((FILE*)x)
#define GDIMAGECREATEFROMWBMP(x) gdImageCreateFromWBMP((FILE*)x)
#define GDIMAGECREATEFROMGD(x)   gdImageCreateFromGd((FILE*)x)
#define GDIMAGECREATEFROMGD2(x)  gdImageCreateFromGd2((FILE*)x)
#define GDIMAGECREATEFROMGD2PART(x,a,b,c,d) gdImageCreateFromGd2Part((FILE*)x,a,b,c,d)
#  endif
#else
#  ifdef USE_PERLIO
#define GDIMAGECREATEFROMPNG(x) gdImageCreateFromPng(PerlIO_findFILE(x))
#define GDIMAGECREATEFROMXBM(x) gdImageCreateFromXbm(PerlIO_findFILE(x))
#define GDIMAGECREATEFROMJPEG(x) gdImageCreateFromJpeg(PerlIO_findFILE(x))
#define GDIMAGECREATEFROMGIF(x)  gdImageCreateFromGif(PerlIO_findFILE(x))
#define GDIMAGECREATEFROMWBMP(x) gdImageCreateFromWBMP(PerlIO_findFILE(x))
#define GDIMAGECREATEFROMGD(x) gdImageCreateFromGd(PerlIO_findFILE(x))
#define GDIMAGECREATEFROMGD2(x) gdImageCreateFromGd2(PerlIO_findFILE(x))
#define GDIMAGECREATEFROMGD2PART(x,a,b,c,d) gdImageCreateFromGd2Part(PerlIO_findFILE(x),a,b,c,d)
#  else
#define GDIMAGECREATEFROMPNG(x) gdImageCreateFromPng(x)
#define GDIMAGECREATEFROMXBM(x) gdImageCreateFromXbm(x)
#define GDIMAGECREATEFROMJPEG(x) gdImageCreateFromJpeg(x)
#define GDIMAGECREATEFROMGIF(x) gdImageCreateFromGif(x)
#define GDIMAGECREATEFROMWBMP(x) gdImageCreateFromWBMP(x)
#define GDIMAGECREATEFROMGD(x) gdImageCreateFromGd(x)
#define GDIMAGECREATEFROMGD2(x) gdImageCreateFromGd2(x)
#define GDIMAGECREATEFROMGD2PART(x,a,b,c,d) gdImageCreateFromGd2Part(x,a,b,c,d)
#  endif
#endif

#define littleendian(a) \
    (a[3]<<24)+(a[2]<<16)+(a[1]<<8)+a[0]

/* definitions required to create images from in-memory buffers */
		     
typedef struct bufIOCtx {
  gdIOCtx    ctx;
  char*      data;
  int        length;
  int        pos;
} bufIOCtx;

typedef struct bufIOCtx *bufIOCtxPtr;

static int bufGetC (gdIOCtxPtr ctx) {
  bufIOCtxPtr bctx = (bufIOCtxPtr) ctx;

  if (bctx->pos >= bctx->length) return EOF;
  return bctx->data[bctx->pos];
}

static int bufGetBuf (gdIOCtxPtr ctx, void* buf, int len) {
  bufIOCtxPtr bctx = (bufIOCtxPtr) ctx;
  int remain,rlen;

  remain = bctx->length - bctx->pos;
  if (remain >= len) {
    rlen = len;
  } else {
    if (remain <= 0) return EOF;
    rlen = remain;
  }
  memcpy(buf,(void*)(bctx->data + bctx->pos),rlen);
  bctx->pos += rlen;
  return rlen;
}

static int bufSeek (gdIOCtxPtr ctx, const int pos) {
  bufIOCtxPtr bctx = (bufIOCtxPtr) ctx;
  bctx->pos = pos;
  if (bctx->pos > bctx->length)
    bctx->pos = bctx->length;
  return TRUE;
}

static long bufTell (gdIOCtxPtr ctx) {
  bufIOCtxPtr bctx = (bufIOCtxPtr) ctx;
  return bctx->pos;
}

static void bufFree(gdIOCtxPtr ctx) {
  Safefree(ctx);
}

static gdIOCtx* newDynamicCtx (char* data, int length) {
  bufIOCtxPtr   ctx;
  
#ifdef Newz
  Newz(0,ctx,1,bufIOCtx);
#else
  Newxz(ctx,1,bufIOCtx);
#endif
  if (ctx == NULL) return NULL;
  ctx->data   = data;
  ctx->pos    = 0;
  ctx->length = length;

  ctx->ctx.getC   = bufGetC;
  ctx->ctx.getBuf = bufGetBuf;
  ctx->ctx.seek   = bufSeek;
  ctx->ctx.tell   = bufTell;
  ctx->ctx.gd_free = bufFree;
  ctx->ctx.putC   = NULL;
  ctx->ctx.putBuf = NULL;
  return (gdIOCtx*)ctx;
}

/* helper routines for image transformation */
static GD__Image
gd_cloneDim(GD__Image src, int x, int y) {
  GD__Image dst;
  if (gdImageTrueColor(src)) {
     dst = (GD__Image) gdImageCreateTrueColor(x,y);
  } else {
     int i;
     dst = (GD__Image) gdImageCreatePalette(x,y);
     /* copy across the palette information */
     for (i = 0; i < gdMaxColors; i++) {
	dst->red[i]   = src->red[i];
	dst->green[i] = src->green[i];
	dst->blue[i]  = src->blue[i];
	dst->alpha[i] = src->alpha[i];
	dst->open[i]  = src->open[i];
     }
     dst->colorsTotal = src->colorsTotal;
     dst->transparent = src->transparent;
     dst->interlace   = src->interlace;
     dst->thick       = src->thick;
  }
  return(dst);
}

void
get_xformbounds(GD__Image src, int *x, int *y,
			int *x1, int *y1, int *x2, int *y2)
{
   *x  = gdImageSX(src);
   *y  = gdImageSY(src);
   *x1 = *x - 1;
   *y1 = *y - 1;
   *x2 = *x / 2;
   *y2 = *y / 2;
}

/* helper macros for image transformations */
#define GDGetImagePixel(im,x,y) \
	gdImageTrueColor(im) ? \
	gdImageTrueColorPixel(im,x,y) : \
	gdImagePalettePixel(im,x,y)

#define GDSetImagePixel(im,x,y,p) \
	gdImageTrueColor(im) ? \
	(gdImageTrueColorPixel(im,x,y) = p) : \
	(gdImagePalettePixel(im,x,y) = p)

#define GDCopyImagePixel(dst,dx,dy,src,sx,sy) \
	gdImageTrueColor(src) ? \
	(gdImageTrueColorPixel(dst,dx,dy)=gdImageTrueColorPixel(src,sx,sy)) : \
	(gdImagePalettePixel(dst,dx,dy)=gdImagePalettePixel(src,sx,sy))

/* Check the image format being returned */
void
gd_chkimagefmt(GD__Image image, int truecolor) {
  if ((image != NULL)
      && !truecolor) {			/* return a palette image */
     if (gdImageTrueColor(image)) {
	gdImageTrueColorToPalette(image,1,gdMaxColors);
     }
  }
}

/* GLOBAL THREAD-SAFE DATA */

#ifdef START_MY_CXT

#define MY_CXT_KEY "GD::_guts" XS_VERSION
typedef struct {
  /* Current image true color default
   *  0 - create palette based images by default
   *  1 - create true color images by default
   */
  int truecolor_default;
} my_cxt_t;

START_MY_CXT
#endif

#line 546 "GD.c"
#ifndef PERL_UNUSED_VAR
#  define PERL_UNUSED_VAR(var) if (0) var = var
#endif

#ifndef dVAR
#  define dVAR		dNOOP
#endif


/* This stuff is not part of the API! You have been warned. */
#ifndef PERL_VERSION_DECIMAL
#  define PERL_VERSION_DECIMAL(r,v,s) (r*1000000 + v*1000 + s)
#endif
#ifndef PERL_DECIMAL_VERSION
#  define PERL_DECIMAL_VERSION \
	  PERL_VERSION_DECIMAL(PERL_REVISION,PERL_VERSION,PERL_SUBVERSION)
#endif
#ifndef PERL_VERSION_GE
#  define PERL_VERSION_GE(r,v,s) \
	  (PERL_DECIMAL_VERSION >= PERL_VERSION_DECIMAL(r,v,s))
#endif
#ifndef PERL_VERSION_LE
#  define PERL_VERSION_LE(r,v,s) \
	  (PERL_DECIMAL_VERSION <= PERL_VERSION_DECIMAL(r,v,s))
#endif

/* XS_INTERNAL is the explicit static-linkage variant of the default
 * XS macro.
 *
 * XS_EXTERNAL is the same as XS_INTERNAL except it does not include
 * "STATIC", ie. it exports XSUB symbols. You probably don't want that
 * for anything but the BOOT XSUB.
 *
 * See XSUB.h in core!
 */


/* TODO: This might be compatible further back than 5.10.0. */
#if PERL_VERSION_GE(5, 10, 0) && PERL_VERSION_LE(5, 15, 1)
#  undef XS_EXTERNAL
#  undef XS_INTERNAL
#  if defined(__CYGWIN__) && defined(USE_DYNAMIC_LOADING)
#    define XS_EXTERNAL(name) __declspec(dllexport) XSPROTO(name)
#    define XS_INTERNAL(name) STATIC XSPROTO(name)
#  endif
#  if defined(__SYMBIAN32__)
#    define XS_EXTERNAL(name) EXPORT_C XSPROTO(name)
#    define XS_INTERNAL(name) EXPORT_C STATIC XSPROTO(name)
#  endif
#  ifndef XS_EXTERNAL
#    if defined(HASATTRIBUTE_UNUSED) && !defined(__cplusplus)
#      define XS_EXTERNAL(name) void name(pTHX_ CV* cv __attribute__unused__)
#      define XS_INTERNAL(name) STATIC void name(pTHX_ CV* cv __attribute__unused__)
#    else
#      ifdef __cplusplus
#        define XS_EXTERNAL(name) extern "C" XSPROTO(name)
#        define XS_INTERNAL(name) static XSPROTO(name)
#      else
#        define XS_EXTERNAL(name) XSPROTO(name)
#        define XS_INTERNAL(name) STATIC XSPROTO(name)
#      endif
#    endif
#  endif
#endif

/* perl >= 5.10.0 && perl <= 5.15.1 */


/* The XS_EXTERNAL macro is used for functions that must not be static
 * like the boot XSUB of a module. If perl didn't have an XS_EXTERNAL
 * macro defined, the best we can do is assume XS is the same.
 * Dito for XS_INTERNAL.
 */
#ifndef XS_EXTERNAL
#  define XS_EXTERNAL(name) XS(name)
#endif
#ifndef XS_INTERNAL
#  define XS_INTERNAL(name) XS(name)
#endif

/* Now, finally, after all this mess, we want an ExtUtils::ParseXS
 * internal macro that we're free to redefine for varying linkage due
 * to the EXPORT_XSUB_SYMBOLS XS keyword. This is internal, use
 * XS_EXTERNAL(name) or XS_INTERNAL(name) in your code if you need to!
 */

#undef XS_EUPXS
#if defined(PERL_EUPXS_ALWAYS_EXPORT)
#  define XS_EUPXS(name) XS_EXTERNAL(name)
#else
   /* default to internal */
#  define XS_EUPXS(name) XS_INTERNAL(name)
#endif

#ifndef PERL_ARGS_ASSERT_CROAK_XS_USAGE
#define PERL_ARGS_ASSERT_CROAK_XS_USAGE assert(cv); assert(params)

/* prototype to pass -Wmissing-prototypes */
STATIC void
S_croak_xs_usage(const CV *const cv, const char *const params);

STATIC void
S_croak_xs_usage(const CV *const cv, const char *const params)
{
    const GV *const gv = CvGV(cv);

    PERL_ARGS_ASSERT_CROAK_XS_USAGE;

    if (gv) {
        const char *const gvname = GvNAME(gv);
        const HV *const stash = GvSTASH(gv);
        const char *const hvname = stash ? HvNAME(stash) : NULL;

        if (hvname)
	    Perl_croak_nocontext("Usage: %s::%s(%s)", hvname, gvname, params);
        else
	    Perl_croak_nocontext("Usage: %s(%s)", gvname, params);
    } else {
        /* Pants. I don't think that it should be possible to get here. */
	Perl_croak_nocontext("Usage: CODE(0x%"UVxf")(%s)", PTR2UV(cv), params);
    }
}
#undef  PERL_ARGS_ASSERT_CROAK_XS_USAGE

#define croak_xs_usage        S_croak_xs_usage

#endif

/* NOTE: the prototype of newXSproto() is different in versions of perls,
 * so we define a portable version of newXSproto()
 */
#ifdef newXS_flags
#define newXSproto_portable(name, c_impl, file, proto) newXS_flags(name, c_impl, file, proto, 0)
#else
#define newXSproto_portable(name, c_impl, file, proto) (PL_Sv=(SV*)newXS(name, c_impl, file), sv_setpv(PL_Sv, proto), (CV*)PL_Sv)
#endif /* !defined(newXS_flags) */

#if PERL_VERSION_LE(5, 21, 5)
#  define newXS_deffile(a,b) Perl_newXS(aTHX_ a,b,file)
#else
#  define newXS_deffile(a,b) Perl_newXS_deffile(aTHX_ a,b)
#endif

#line 690 "GD.c"

XS_EUPXS(XS_GD_constant); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_GD_constant)
{
    dVAR; dXSARGS;
    if (items != 1)
       croak_xs_usage(cv,  "name");
    {
	char *	name = (char *)SvPV_nolen(ST(0))
;
	double	RETVAL;
	dXSTARG;

	RETVAL = constant(name);
	XSprePUSH; PUSHn((double)RETVAL);
    }
    XSRETURN(1);
}


XS_EUPXS(XS_GD__Image_trueColor); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_GD__Image_trueColor)
{
    dVAR; dXSARGS;
    PERL_UNUSED_VAR(cv); /* -W */
    {
	char *	packname;
#line 560 "GD.xs"
#ifdef START_MY_CXT
        dMY_CXT;
        int previous_value = MY_CXT.truecolor_default;
#else
        int previous_value = truecolor_default;
#endif
#line 725 "GD.c"
	int	RETVAL;
	dXSTARG;

	if (items < 1)
	    packname = "GD::Image";
	else {
	    packname = (char *)SvPV_nolen(ST(0))
;
	}
#line 567 "GD.xs"
	{
          if (items > 1)
#ifdef START_MY_CXT
	    MY_CXT.truecolor_default = (int)SvIV(ST(1));
#else
            truecolor_default = (int)SvIV(ST(1));
#endif
          RETVAL = previous_value;
	}
#line 745 "GD.c"
	XSprePUSH; PUSHi((IV)RETVAL);
    }
    XSRETURN(1);
}


XS_EUPXS(XS_GD__Image__new); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_GD__Image__new)
{
    dVAR; dXSARGS;
    PERL_UNUSED_VAR(cv); /* -W */
    {
	char *	packname;
	int	x;
	int	y;
#line 586 "GD.xs"
#ifdef START_MY_CXT
        dMY_CXT;
	int truecolor = MY_CXT.truecolor_default;
#else
        int truecolor = truecolor_default;
#endif
#line 768 "GD.c"
	GD__Image	RETVAL;

	if (items < 1)
	    packname = "GD::Image";
	else {
	    packname = (char *)SvPV_nolen(ST(0))
;
	}

	if (items < 2)
	    x = 64;
	else {
	    x = (int)SvIV(ST(1))
;
	}

	if (items < 3)
	    y = 64;
	else {
	    y = (int)SvIV(ST(2))
;
	}
#line 593 "GD.xs"
	{
		gdImagePtr theImage;
                if (items > 3)
		  truecolor = (int)SvIV(ST(3));
		if (truecolor) {
		   theImage = (GD__Image) gdImageCreateTrueColor(x,y);
		} else {
		   theImage = (GD__Image) gdImageCreate(x,y);
		}
		RETVAL = theImage;
	}
#line 803 "GD.c"
	{
	    SV * RETVALSV;
	    RETVALSV = sv_newmortal();
	    sv_setref_pv(RETVALSV, "GD::Image", (void*)RETVAL);
	    ST(0) = RETVALSV;
	}
    }
    XSRETURN(1);
}

#ifdef HAVE_PNG
#define XSubPPtmpAAAA 1


XS_EUPXS(XS_GD__Image__newFromPng); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_GD__Image__newFromPng)
{
    dVAR; dXSARGS;
    if (items < 1)
       croak_xs_usage(cv,  "packname=\"GD::Image\", filehandle, ...");
    {
	char *	packname;
	InputStream	filehandle = IoIFP(sv_2io(ST(1)))
;
#line 614 "GD.xs"
#ifdef START_MY_CXT
        dMY_CXT;
	int truecolor = MY_CXT.truecolor_default;
#else
        int truecolor = truecolor_default;
#endif
#line 835 "GD.c"
	GD__Image	RETVAL;

	if (items < 1)
	    packname = "GD::Image";
	else {
	    packname = (char *)SvPV_nolen(ST(0))
;
	}
#line 621 "GD.xs"
	RETVAL = (GD__Image) GDIMAGECREATEFROMPNG(filehandle);
        if (items > 2) truecolor = (int)SvIV(ST(2));
	gd_chkimagefmt(RETVAL, truecolor);
#line 848 "GD.c"
	{
	    SV * RETVALSV;
	    RETVALSV = sv_newmortal();
	    sv_setref_pv(RETVALSV, "GD::Image", (void*)RETVAL);
	    ST(0) = RETVALSV;
	}
    }
    XSRETURN(1);
}


XS_EUPXS(XS_GD__Image_newFromPngData); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_GD__Image_newFromPngData)
{
    dVAR; dXSARGS;
    if (items < 1)
       croak_xs_usage(cv,  "packname=\"GD::Image\", imageData, ...");
    {
	char *	packname;
	SV *	imageData = ST(1)
;
#line 633 "GD.xs"
	  gdIOCtx* ctx;
          char*    data;
          STRLEN   len;
#ifdef START_MY_CXT
	  dMY_CXT;
	  int truecolor = MY_CXT.truecolor_default;
#else
          int truecolor = truecolor_default;
#endif
#line 880 "GD.c"
	GD__Image	RETVAL;

	if (items < 1)
	    packname = "GD::Image";
	else {
	    packname = (char *)SvPV_nolen(ST(0))
;
	}
#line 643 "GD.xs"
	data = SvPV(imageData,len);
        ctx = newDynamicCtx(data,len);
	RETVAL = (GD__Image) gdImageCreateFromPngCtx(ctx);
        (ctx->gd_free)(ctx);
        if (items > 2) truecolor = (int)SvIV(ST(2));
	gd_chkimagefmt(RETVAL, truecolor);
#line 896 "GD.c"
	{
	    SV * RETVALSV;
	    RETVALSV = sv_newmortal();
	    sv_setref_pv(RETVALSV, "GD::Image", (void*)RETVAL);
	    ST(0) = RETVALSV;
	}
    }
    XSRETURN(1);
}

#endif

XS_EUPXS(XS_GD__Image_newFromGdData); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_GD__Image_newFromGdData)
{
    dVAR; dXSARGS;
    if (items < 1 || items > 2)
       croak_xs_usage(cv,  "packname=\"GD::Image\", imageData");
    {
	char *	packname;
	SV *	imageData = ST(1)
;
#line 660 "GD.xs"
          char*    data;
          STRLEN   len;
#line 922 "GD.c"
	GD__Image	RETVAL;

	if (items < 1)
	    packname = "GD::Image";
	else {
	    packname = (char *)SvPV_nolen(ST(0))
;
	}
#line 663 "GD.xs"
	data = SvPV(imageData,len);
	RETVAL = (GD__Image) gdImageCreateFromGdPtr(len,(void*) data);
#line 934 "GD.c"
	{
	    SV * RETVALSV;
	    RETVALSV = sv_newmortal();
	    sv_setref_pv(RETVALSV, "GD::Image", (void*)RETVAL);
	    ST(0) = RETVALSV;
	}
    }
    XSRETURN(1);
}


XS_EUPXS(XS_GD__Image_newFromGd2Data); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_GD__Image_newFromGd2Data)
{
    dVAR; dXSARGS;
    if (items < 1 || items > 2)
       croak_xs_usage(cv,  "packname=\"GD::Image\", imageData");
    {
	char *	packname;
	SV *	imageData = ST(1)
;
#line 674 "GD.xs"
          char*    data;
          STRLEN   len;
#line 959 "GD.c"
	GD__Image	RETVAL;

	if (items < 1)
	    packname = "GD::Image";
	else {
	    packname = (char *)SvPV_nolen(ST(0))
;
	}
#line 677 "GD.xs"
	data = SvPV(imageData,len);
	RETVAL = (GD__Image) gdImageCreateFromGd2Ptr(len,(void*) data);
#line 971 "GD.c"
	{
	    SV * RETVALSV;
	    RETVALSV = sv_newmortal();
	    sv_setref_pv(RETVALSV, "GD::Image", (void*)RETVAL);
	    ST(0) = RETVALSV;
	}
    }
    XSRETURN(1);
}

#ifdef HAVE_JPEG
#define XSubPPtmpAAAB 1


XS_EUPXS(XS_GD__Image_newFromJpegData); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_GD__Image_newFromJpegData)
{
    dVAR; dXSARGS;
    if (items < 1)
       croak_xs_usage(cv,  "packname=\"GD::Image\", imageData, ...");
    {
	char *	packname;
	SV *	imageData = ST(1)
;
#line 689 "GD.xs"
	  gdIOCtx* ctx;
          char*    data;
          STRLEN   len;
#ifdef START_MY_CXT
	  dMY_CXT;
          int     truecolor = MY_CXT.truecolor_default;
#else
          int     truecolor = truecolor_default;
#endif
#line 1006 "GD.c"
	GD__Image	RETVAL;

	if (items < 1)
	    packname = "GD::Image";
	else {
	    packname = (char *)SvPV_nolen(ST(0))
;
	}
#line 699 "GD.xs"
	  data = SvPV(imageData,len);
          ctx = newDynamicCtx(data,len);
          RETVAL = (GD__Image) gdImageCreateFromJpegCtx(ctx);
          (ctx->gd_free)(ctx);
          if (items > 2) truecolor = (int)SvIV(ST(2));
	  gd_chkimagefmt(RETVAL, truecolor);
#line 1022 "GD.c"
	{
	    SV * RETVALSV;
	    RETVALSV = sv_newmortal();
	    sv_setref_pv(RETVALSV, "GD::Image", (void*)RETVAL);
	    ST(0) = RETVALSV;
	}
    }
    XSRETURN(1);
}

#endif

XS_EUPXS(XS_GD__Image_newFromWBMPData); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_GD__Image_newFromWBMPData)
{
    dVAR; dXSARGS;
    if (items < 1)
       croak_xs_usage(cv,  "packname=\"GD::Image\", imageData, ...");
    {
	char *	packname;
	SV *	imageData = ST(1)
;
#line 716 "GD.xs"
	  gdIOCtx* ctx;
          char*    data;
          STRLEN   len;
#ifdef START_MY_CXT
	  dMY_CXT;
          int     truecolor = MY_CXT.truecolor_default;
#else
          int     truecolor = truecolor_default;
#endif
#line 1055 "GD.c"
	GD__Image	RETVAL;

	if (items < 1)
	    packname = "GD::Image";
	else {
	    packname = (char *)SvPV_nolen(ST(0))
;
	}
#line 726 "GD.xs"
	data = SvPV(imageData,len);
        ctx = newDynamicCtx(data,len);
	RETVAL = (GD__Image) gdImageCreateFromWBMPCtx(ctx);
        (ctx->gd_free)(ctx);
        if (items > 2) truecolor = (int)SvIV(ST(2));
	gd_chkimagefmt(RETVAL, truecolor);
#line 1071 "GD.c"
	{
	    SV * RETVALSV;
	    RETVALSV = sv_newmortal();
	    sv_setref_pv(RETVALSV, "GD::Image", (void*)RETVAL);
	    ST(0) = RETVALSV;
	}
    }
    XSRETURN(1);
}


XS_EUPXS(XS_GD__Image__newFromXbm); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_GD__Image__newFromXbm)
{
    dVAR; dXSARGS;
    if (items < 1 || items > 2)
       croak_xs_usage(cv,  "packname=\"GD::Image\", filehandle");
    {
	char *	packname;
	InputStream	filehandle = IoIFP(sv_2io(ST(1)))
;
	GD__Image	RETVAL;

	if (items < 1)
	    packname = "GD::Image";
	else {
	    packname = (char *)SvPV_nolen(ST(0))
;
	}
#line 741 "GD.xs"
	RETVAL = GDIMAGECREATEFROMXBM(filehandle);
#line 1103 "GD.c"
	{
	    SV * RETVALSV;
	    RETVALSV = sv_newmortal();
	    sv_setref_pv(RETVALSV, "GD::Image", (void*)RETVAL);
	    ST(0) = RETVALSV;
	}
    }
    XSRETURN(1);
}


XS_EUPXS(XS_GD__Image__newFromGd); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_GD__Image__newFromGd)
{
    dVAR; dXSARGS;
    if (items < 1 || items > 2)
       croak_xs_usage(cv,  "packname=\"GD::Image\", filehandle");
    {
	char *	packname;
	InputStream	filehandle = IoIFP(sv_2io(ST(1)))
;
	GD__Image	RETVAL;

	if (items < 1)
	    packname = "GD::Image";
	else {
	    packname = (char *)SvPV_nolen(ST(0))
;
	}
#line 751 "GD.xs"
	RETVAL = GDIMAGECREATEFROMGD(filehandle);
#line 1135 "GD.c"
	{
	    SV * RETVALSV;
	    RETVALSV = sv_newmortal();
	    sv_setref_pv(RETVALSV, "GD::Image", (void*)RETVAL);
	    ST(0) = RETVALSV;
	}
    }
    XSRETURN(1);
}


XS_EUPXS(XS_GD__Image__newFromGd2); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_GD__Image__newFromGd2)
{
    dVAR; dXSARGS;
    if (items < 1 || items > 2)
       croak_xs_usage(cv,  "packname=\"GD::Image\", filehandle");
    {
	char *	packname;
	InputStream	filehandle = IoIFP(sv_2io(ST(1)))
;
	GD__Image	RETVAL;

	if (items < 1)
	    packname = "GD::Image";
	else {
	    packname = (char *)SvPV_nolen(ST(0))
;
	}
#line 761 "GD.xs"
	RETVAL = GDIMAGECREATEFROMGD2(filehandle);
#line 1167 "GD.c"
	{
	    SV * RETVALSV;
	    RETVALSV = sv_newmortal();
	    sv_setref_pv(RETVALSV, "GD::Image", (void*)RETVAL);
	    ST(0) = RETVALSV;
	}
    }
    XSRETURN(1);
}

#ifdef HAVE_JPEG
#define XSubPPtmpAAAC 1


XS_EUPXS(XS_GD__Image__newFromJpeg); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_GD__Image__newFromJpeg)
{
    dVAR; dXSARGS;
    if (items < 1)
       croak_xs_usage(cv,  "packname=\"GD::Image\", filehandle, ...");
    {
	char *	packname;
	InputStream	filehandle = IoIFP(sv_2io(ST(1)))
;
#line 772 "GD.xs"
#ifdef START_MY_CXT
	  dMY_CXT;
          int     truecolor = MY_CXT.truecolor_default;
#else
          int     truecolor = truecolor_default;
#endif
#line 1199 "GD.c"
	GD__Image	RETVAL;

	if (items < 1)
	    packname = "GD::Image";
	else {
	    packname = (char *)SvPV_nolen(ST(0))
;
	}
#line 779 "GD.xs"
	  RETVAL = GDIMAGECREATEFROMJPEG(filehandle);
          if (items > 2) truecolor = (int)SvIV(ST(2));
	  gd_chkimagefmt(RETVAL, truecolor);
#line 1212 "GD.c"
	{
	    SV * RETVALSV;
	    RETVALSV = sv_newmortal();
	    sv_setref_pv(RETVALSV, "GD::Image", (void*)RETVAL);
	    ST(0) = RETVALSV;
	}
    }
    XSRETURN(1);
}

#endif

XS_EUPXS(XS_GD__Image__newFromWBMP); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_GD__Image__newFromWBMP)
{
    dVAR; dXSARGS;
    if (items < 1 || items > 2)
       croak_xs_usage(cv,  "packname=\"GD::Image\", filehandle");
    {
	char *	packname;
	InputStream	filehandle = IoIFP(sv_2io(ST(1)))
;
#line 793 "GD.xs"
	  gdImagePtr img;
	  SV* errormsg;
#line 1238 "GD.c"
	GD__Image	RETVAL;

	if (items < 1)
	    packname = "GD::Image";
	else {
	    packname = (char *)SvPV_nolen(ST(0))
;
	}
#line 796 "GD.xs"
	img = GDIMAGECREATEFROMWBMP(filehandle);
        if (img == NULL) {
          errormsg = perl_get_sv("@",0);
	  if (errormsg != NULL)
	    sv_setpv(errormsg,"libgd was not built with WBMP support\n");
	  XSRETURN_EMPTY;
        }
        RETVAL = img;
#line 1256 "GD.c"
	{
	    SV * RETVALSV;
	    RETVALSV = sv_newmortal();
	    sv_setref_pv(RETVALSV, "GD::Image", (void*)RETVAL);
	    ST(0) = RETVALSV;
	}
    }
    XSRETURN(1);
}


XS_EUPXS(XS_GD__Image_newFromXpm); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_GD__Image_newFromXpm)
{
    dVAR; dXSARGS;
    if (items < 1 || items > 2)
       croak_xs_usage(cv,  "packname=\"GD::Image\", filename");
    {
	char *	packname;
	char *	filename = (char *)SvPV_nolen(ST(1))
;
#line 813 "GD.xs"
	  gdImagePtr img;
	  SV* errormsg;
#line 1281 "GD.c"
	GD__Image	RETVAL;

	if (items < 1)
	    packname = "GD::Image";
	else {
	    packname = (char *)SvPV_nolen(ST(0))
;
	}
#line 816 "GD.xs"
#ifdef HAVE_XPM
        img = (GD__Image) gdImageCreateFromXpm(filename);
        if (img == NULL) {
            errormsg = perl_get_sv("@",0);
            if (errormsg != NULL)
              sv_setpv(errormsg,"libgd was not built with xpm support\n");
            XSRETURN_EMPTY;
        }
        RETVAL = img;
#else
        errormsg = perl_get_sv("@",0);
        sv_setpv(errormsg,"libgd was not built with xpm support\n");
        XSRETURN_EMPTY;
#endif
#line 1305 "GD.c"
	{
	    SV * RETVALSV;
	    RETVALSV = sv_newmortal();
	    sv_setref_pv(RETVALSV, "GD::Image", (void*)RETVAL);
	    ST(0) = RETVALSV;
	}
    }
    XSRETURN(1);
}


XS_EUPXS(XS_GD__Image__newFromGd2Part); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_GD__Image__newFromGd2Part)
{
    dVAR; dXSARGS;
    if (items < 5 || items > 6)
       croak_xs_usage(cv,  "packname=\"GD::Image\", filehandle, srcX, srcY, width, height");
    {
	char *	packname;
	InputStream	filehandle = IoIFP(sv_2io(ST(1)))
;
	int	srcX = (int)SvIV(ST(2))
;
	int	srcY = (int)SvIV(ST(3))
;
	int	width = (int)SvIV(ST(4))
;
	int	height = (int)SvIV(ST(5))
;
	GD__Image	RETVAL;

	if (items < 1)
	    packname = "GD::Image";
	else {
	    packname = (char *)SvPV_nolen(ST(0))
;
	}
#line 843 "GD.xs"
	RETVAL = GDIMAGECREATEFROMGD2PART(filehandle,srcX,srcY,width,height);
#line 1345 "GD.c"
	{
	    SV * RETVALSV;
	    RETVALSV = sv_newmortal();
	    sv_setref_pv(RETVALSV, "GD::Image", (void*)RETVAL);
	    ST(0) = RETVALSV;
	}
    }
    XSRETURN(1);
}

#ifdef HAVE_GIF
#define XSubPPtmpAAAD 1


XS_EUPXS(XS_GD__Image__newFromGif); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_GD__Image__newFromGif)
{
    dVAR; dXSARGS;
    if (items < 1 || items > 2)
       croak_xs_usage(cv,  "packname=\"GD::Image\", filehandle");
    {
	char *	packname;
	InputStream	filehandle = IoIFP(sv_2io(ST(1)))
;
#line 854 "GD.xs"
#ifdef START_MY_CXT
	  dMY_CXT;
          int     truecolor = MY_CXT.truecolor_default;
#else
          int     truecolor = truecolor_default;
#endif
#line 1377 "GD.c"
	GD__Image	RETVAL;

	if (items < 1)
	    packname = "GD::Image";
	else {
	    packname = (char *)SvPV_nolen(ST(0))
;
	}
#line 861 "GD.xs"
	  RETVAL = GDIMAGECREATEFROMGIF(filehandle);
#line 1388 "GD.c"
	{
	    SV * RETVALSV;
	    RETVALSV = sv_newmortal();
	    sv_setref_pv(RETVALSV, "GD::Image", (void*)RETVAL);
	    ST(0) = RETVALSV;
	}
    }
    XSRETURN(1);
}


XS_EUPXS(XS_GD__Image_newFromGifData); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_GD__Image_newFromGifData)
{
    dVAR; dXSARGS;
    if (items < 1 || items > 2)
       croak_xs_usage(cv,  "packname=\"GD::Image\", imageData");
    {
	char *	packname;
	SV *	imageData = ST(1)
;
#line 871 "GD.xs"
	  gdIOCtx* ctx;
          char*    data;
          STRLEN   len;
#ifdef START_MY_CXT
	  dMY_CXT;
          int     truecolor = MY_CXT.truecolor_default;
#else
          int     truecolor = truecolor_default;
#endif
#line 1420 "GD.c"
	GD__Image	RETVAL;

	if (items < 1)
	    packname = "GD::Image";
	else {
	    packname = (char *)SvPV_nolen(ST(0))
;
	}
#line 881 "GD.xs"
	data = SvPV(imageData,len);
        ctx = newDynamicCtx(data,len);
	RETVAL = (GD__Image) gdImageCreateFromGifCtx(ctx);
        (ctx->gd_free)(ctx);
#line 1434 "GD.c"
	{
	    SV * RETVALSV;
	    RETVALSV = sv_newmortal();
	    sv_setref_pv(RETVALSV, "GD::Image", (void*)RETVAL);
	    ST(0) = RETVALSV;
	}
    }
    XSRETURN(1);
}

#endif

XS_EUPXS(XS_GD__Image_DESTROY); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_GD__Image_DESTROY)
{
    dVAR; dXSARGS;
    if (items != 1)
       croak_xs_usage(cv,  "image");
    {
	GD__Image	image;

	if (SvROK(ST(0))) {
	    IV tmp = SvIV((SV*)SvRV(ST(0)));
	    image = INT2PTR(GD__Image,tmp);
	}
	else
	    Perl_croak_nocontext("%s: %s is not a reference",
			"GD::Image::DESTROY",
			"image")
;
#line 895 "GD.xs"
	{
  	  gdImageDestroy(image);
	}
#line 1469 "GD.c"
    }
    XSRETURN_EMPTY;
}


XS_EUPXS(XS_GD__Image_STORABLE_freeze); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_GD__Image_STORABLE_freeze)
{
    dVAR; dXSARGS;
    if (items != 2)
       croak_xs_usage(cv,  "image, cloning");
    {
	GD__Image	image;
	int	cloning = (int)SvIV(ST(1))
;
	SV *	RETVAL;

	if (SvROK(ST(0)) && sv_derived_from(ST(0), "GD::Image")) {
	    IV tmp = SvIV((SV*)SvRV(ST(0)));
	    image = INT2PTR(GD__Image,tmp);
	}
	else
	    Perl_croak_nocontext("%s: %s is not of type %s",
			"GD::Image::STORABLE_freeze",
			"image", "GD::Image")
;
#line 904 "GD.xs"
     {
       void*     data;
       int       size;

       if (cloning) XSRETURN_UNDEF;
       data = gdImageGd2Ptr(image,0,GD2_FMT_COMPRESSED,&size);
       RETVAL=newSVpvn((char*)data,size);
       gdFree(data);
     }
#line 1506 "GD.c"
	RETVAL = sv_2mortal(RETVAL);
	ST(0) = RETVAL;
    }
    XSRETURN(1);
}


XS_EUPXS(XS_GD__Image_STORABLE_thaw); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_GD__Image_STORABLE_thaw)
{
    dVAR; dXSARGS;
    if (items != 3)
       croak_xs_usage(cv,  "object, cloning, serialized");
    {
	SV*	object = ST(0)
;
	int	cloning = (int)SvIV(ST(1))
;
	SV*	serialized = ST(2)
;
#line 921 "GD.xs"
     STRLEN    length;
     void*     data;
     GD__Image image;
#line 1531 "GD.c"
#line 925 "GD.xs"
     {
       if (cloning) XSRETURN_UNDEF;
       data = (void*) SvPV(serialized,length);
       image = gdImageCreateFromGd2Ptr(length,data);
/*       sv_setiv(SvRV(object),(int)image); */
       sv_setiv(SvRV(object),(long int)image);
     }
#line 1540 "GD.c"
    }
    XSRETURN_EMPTY;
}

#ifdef HAVE_PNG
#define XSubPPtmpAAAE 1


XS_EUPXS(XS_GD__Image_png); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_GD__Image_png)
{
    dVAR; dXSARGS;
    if (items < 1)
       croak_xs_usage(cv,  "image, ...");
    {
	GD__Image	image;
#line 939 "GD.xs"
#line 1558 "GD.c"
	SV *	RETVAL;

	if (SvROK(ST(0)) && sv_derived_from(ST(0), "GD::Image")) {
	    IV tmp = SvIV((SV*)SvRV(ST(0)));
	    image = INT2PTR(GD__Image,tmp);
	}
	else
	    Perl_croak_nocontext("%s: %s is not of type %s",
			"GD::Image::png",
			"image", "GD::Image")
;
#line 940 "GD.xs"
  {
	void*         data;
	int           size;
	int           level;
        if (items > 1) {
	  level = (int)SvIV(ST(1));
	  data  = (void *) gdImagePngPtrEx(image,&size,level);
	} else {
	  data = (void *) gdImagePngPtr(image,&size);
	}
	RETVAL = newSVpvn((char*) data,size);
	gdFree(data);
  }
#line 1584 "GD.c"
	RETVAL = sv_2mortal(RETVAL);
	ST(0) = RETVAL;
    }
    XSRETURN(1);
}

#endif
#ifdef HAVE_JPEG
#define XSubPPtmpAAAF 1


XS_EUPXS(XS_GD__Image_jpeg); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_GD__Image_jpeg)
{
    dVAR; dXSARGS;
    if (items < 1 || items > 2)
       croak_xs_usage(cv,  "image, quality=-1");
    {
	GD__Image	image;
	int	quality;
#line 965 "GD.xs"
  SV* errormsg;
#line 1607 "GD.c"
	SV *	RETVAL;

	if (SvROK(ST(0)) && sv_derived_from(ST(0), "GD::Image")) {
	    IV tmp = SvIV((SV*)SvRV(ST(0)));
	    image = INT2PTR(GD__Image,tmp);
	}
	else
	    Perl_croak_nocontext("%s: %s is not of type %s",
			"GD::Image::jpeg",
			"image", "GD::Image")
;

	if (items < 2)
	    quality = -1;
	else {
	    quality = (int)SvIV(ST(1))
;
	}
#line 967 "GD.xs"
  {
	void*         data;
	int           size;
	data = (void *) gdImageJpegPtr(image,&size,quality);
        if (data == NULL) {
          errormsg = perl_get_sv("@",0);
	  if (errormsg != NULL)
	    sv_setpv(errormsg,"libgd was not built with jpeg support\n");
	  XSRETURN_EMPTY;
        }
	RETVAL = newSVpvn((char*) data,size);
	gdFree(data);
  }
#line 1640 "GD.c"
	RETVAL = sv_2mortal(RETVAL);
	ST(0) = RETVAL;
    }
    XSRETURN(1);
}

#endif

XS_EUPXS(XS_GD__Image_gifanimbegin); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_GD__Image_gifanimbegin)
{
    dVAR; dXSARGS;
    if (items < 1 || items > 3)
       croak_xs_usage(cv,  "image, globalcm=-1, loops=-1");
    {
	GD__Image	image;
	int	globalcm;
	int	loops;
#line 992 "GD.xs"
#line 1660 "GD.c"
	SV *	RETVAL;

	if (SvROK(ST(0)) && sv_derived_from(ST(0), "GD::Image")) {
	    IV tmp = SvIV((SV*)SvRV(ST(0)));
	    image = INT2PTR(GD__Image,tmp);
	}
	else
	    Perl_croak_nocontext("%s: %s is not of type %s",
			"GD::Image::gifanimbegin",
			"image", "GD::Image")
;

	if (items < 2)
	    globalcm = -1;
	else {
	    globalcm = (int)SvIV(ST(1))
;
	}

	if (items < 3)
	    loops = -1;
	else {
	    loops = (int)SvIV(ST(2))
;
	}
#line 993 "GD.xs"
  {
	void*         data;
	int           size;
#ifdef HAVE_ANIMGIF
	data = (void *) gdImageGifAnimBeginPtr(image,&size,globalcm,loops);
	RETVAL = newSVpvn((char*) data,size);
	gdFree(data);
#else
        die("libgd 2.0.33 or higher required for animated GIF support");
#endif
  }
#line 1698 "GD.c"
	RETVAL = sv_2mortal(RETVAL);
	ST(0) = RETVAL;
    }
    XSRETURN(1);
}


XS_EUPXS(XS_GD__Image_gifanimadd); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_GD__Image_gifanimadd)
{
    dVAR; dXSARGS;
    if (items < 1 || items > 7)
       croak_xs_usage(cv,  "image, localcm=-1, leftofs=-1, topofs=-1, delay=-1, disposal=-1, previm=0");
    {
	GD__Image	image;
	int	localcm;
	int	leftofs;
	int	topofs;
	int	delay;
	int	disposal;
	GD__Image	previm;
	SV *	RETVAL;

	if (SvROK(ST(0)) && sv_derived_from(ST(0), "GD::Image")) {
	    IV tmp = SvIV((SV*)SvRV(ST(0)));
	    image = INT2PTR(GD__Image,tmp);
	}
	else
	    Perl_croak_nocontext("%s: %s is not of type %s",
			"GD::Image::gifanimadd",
			"image", "GD::Image")
;

	if (items < 2)
	    localcm = -1;
	else {
	    localcm = (int)SvIV(ST(1))
;
	}

	if (items < 3)
	    leftofs = -1;
	else {
	    leftofs = (int)SvIV(ST(2))
;
	}

	if (items < 4)
	    topofs = -1;
	else {
	    topofs = (int)SvIV(ST(3))
;
	}

	if (items < 5)
	    delay = -1;
	else {
	    delay = (int)SvIV(ST(4))
;
	}

	if (items < 6)
	    disposal = -1;
	else {
	    disposal = (int)SvIV(ST(5))
;
	}

	if (items < 7)
	    previm = 0;
	else {
	    if (SvROK(ST(6)) && sv_derived_from(ST(6), "GD::Image")) {
		IV tmp = SvIV((SV*)SvRV(ST(6)));
		previm = INT2PTR(GD__Image,tmp);
	    }
	    else
		Perl_croak_nocontext("%s: %s is not of type %s",
			    "GD::Image::gifanimadd",
			    "previm", "GD::Image")
;
	}
#line 1018 "GD.xs"
  {
	void*         data;
	int           size;
#ifdef HAVE_ANIMGIF
	data = (void *) gdImageGifAnimAddPtr(image,&size,localcm,leftofs,topofs,delay,disposal,previm);
	RETVAL = newSVpvn((char*) data,size);
	gdFree(data);
#else
        die("libgd 2.0.33 or higher required for animated GIF support");
#endif
  }
#line 1792 "GD.c"
	RETVAL = sv_2mortal(RETVAL);
	ST(0) = RETVAL;
    }
    XSRETURN(1);
}


XS_EUPXS(XS_GD__Image_gifanimend); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_GD__Image_gifanimend)
{
    dVAR; dXSARGS;
    if (items != 1)
       croak_xs_usage(cv,  "image");
    {
	GD__Image	image;
	SV *	RETVAL;

	if (SvROK(ST(0)) && sv_derived_from(ST(0), "GD::Image")) {
	    IV tmp = SvIV((SV*)SvRV(ST(0)));
	    image = INT2PTR(GD__Image,tmp);
	}
	else
	    Perl_croak_nocontext("%s: %s is not of type %s",
			"GD::Image::gifanimend",
			"image", "GD::Image")
;
#line 1037 "GD.xs"
  {
	void*         data;
	int           size;
#ifdef HAVE_ANIMGIF
	data = (void *) gdImageGifAnimEndPtr(&size);
	RETVAL = newSVpvn((char*) data,size);
	gdFree(data);
#else
        die("libgd 2.0.33 or higher required for animated GIF support");
#endif
  }
#line 1831 "GD.c"
	RETVAL = sv_2mortal(RETVAL);
	ST(0) = RETVAL;
    }
    XSRETURN(1);
}


XS_EUPXS(XS_GD__Image_wbmp); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_GD__Image_wbmp)
{
    dVAR; dXSARGS;
    if (items != 2)
       croak_xs_usage(cv,  "image, fg");
    {
	GD__Image	image;
	int	fg = (int)SvIV(ST(1))
;
#line 1057 "GD.xs"
  SV* errormsg;
#line 1851 "GD.c"
	SV *	RETVAL;

	if (SvROK(ST(0)) && sv_derived_from(ST(0), "GD::Image")) {
	    IV tmp = SvIV((SV*)SvRV(ST(0)));
	    image = INT2PTR(GD__Image,tmp);
	}
	else
	    Perl_croak_nocontext("%s: %s is not of type %s",
			"GD::Image::wbmp",
			"image", "GD::Image")
;
#line 1059 "GD.xs"
  {
	void*         data;
	int           size;
	data = (void *) gdImageWBMPPtr(image,&size,fg);
        if (data == NULL) {
          errormsg = perl_get_sv("@",0);
	  if (errormsg != NULL)
	    sv_setpv(errormsg,"libgd was not built with WBMP support\n");
	  XSRETURN_EMPTY;
        }
	RETVAL = newSVpvn((char*) data,size);
	gdFree(data);
  }
#line 1877 "GD.c"
	RETVAL = sv_2mortal(RETVAL);
	ST(0) = RETVAL;
    }
    XSRETURN(1);
}

#ifdef HAVE_GIF
#define XSubPPtmpAAAG 1


XS_EUPXS(XS_GD__Image_gif); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_GD__Image_gif)
{
    dVAR; dXSARGS;
    if (items != 1)
       croak_xs_usage(cv,  "image");
    {
	GD__Image	image;
#line 1081 "GD.xs"
  SV* errormsg;
#line 1898 "GD.c"
	SV *	RETVAL;

	if (SvROK(ST(0)) && sv_derived_from(ST(0), "GD::Image")) {
	    IV tmp = SvIV((SV*)SvRV(ST(0)));
	    image = INT2PTR(GD__Image,tmp);
	}
	else
	    Perl_croak_nocontext("%s: %s is not of type %s",
			"GD::Image::gif",
			"image", "GD::Image")
;
#line 1083 "GD.xs"
  {
	void*         data;
	int           size;
	data = (void *) gdImageGifPtr(image,&size);
        if (data == NULL) {
          errormsg = perl_get_sv("@",0);
	  if (errormsg != NULL)
	    sv_setpv(errormsg,"libgd was not built with gif support\n");
	  XSRETURN_EMPTY;
        }
	RETVAL = newSVpvn((char*) data,size);
	gdFree(data);
  }
#line 1924 "GD.c"
	RETVAL = sv_2mortal(RETVAL);
	ST(0) = RETVAL;
    }
    XSRETURN(1);
}

#endif

XS_EUPXS(XS_GD__Image_gd); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_GD__Image_gd)
{
    dVAR; dXSARGS;
    if (items != 1)
       croak_xs_usage(cv,  "image");
    {
	GD__Image	image;
	SV *	RETVAL;

	if (SvROK(ST(0)) && sv_derived_from(ST(0), "GD::Image")) {
	    IV tmp = SvIV((SV*)SvRV(ST(0)));
	    image = INT2PTR(GD__Image,tmp);
	}
	else
	    Perl_croak_nocontext("%s: %s is not of type %s",
			"GD::Image::gd",
			"image", "GD::Image")
;
#line 1106 "GD.xs"
  {
	void*         data;
	int           size;
	data = gdImageGdPtr(image,&size);
	RETVAL = newSVpvn((char*) data,size);
	gdFree(data);
  }
#line 1960 "GD.c"
	RETVAL = sv_2mortal(RETVAL);
	ST(0) = RETVAL;
    }
    XSRETURN(1);
}


XS_EUPXS(XS_GD__Image_gd2); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_GD__Image_gd2)
{
    dVAR; dXSARGS;
    if (items != 1)
       croak_xs_usage(cv,  "image");
    {
	GD__Image	image;
	SV *	RETVAL;

	if (SvROK(ST(0)) && sv_derived_from(ST(0), "GD::Image")) {
	    IV tmp = SvIV((SV*)SvRV(ST(0)));
	    image = INT2PTR(GD__Image,tmp);
	}
	else
	    Perl_croak_nocontext("%s: %s is not of type %s",
			"GD::Image::gd2",
			"image", "GD::Image")
;
#line 1121 "GD.xs"
  {
	void*         data;
	int           size;
	data = gdImageGd2Ptr(image,0,GD2_FMT_COMPRESSED,&size);
	RETVAL = newSVpvn((char*) data,size);
	gdFree(data);
  }
#line 1995 "GD.c"
	RETVAL = sv_2mortal(RETVAL);
	ST(0) = RETVAL;
    }
    XSRETURN(1);
}


XS_EUPXS(XS_GD__Image_transparent); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_GD__Image_transparent)
{
    dVAR; dXSARGS;
    if (items < 1)
       croak_xs_usage(cv,  "image, ...");
    {
	GD__Image	image;
	int	RETVAL;
	dXSTARG;

	if (SvROK(ST(0)) && sv_derived_from(ST(0), "GD::Image")) {
	    IV tmp = SvIV((SV*)SvRV(ST(0)));
	    image = INT2PTR(GD__Image,tmp);
	}
	else
	    Perl_croak_nocontext("%s: %s is not of type %s",
			"GD::Image::transparent",
			"image", "GD::Image")
;
#line 1136 "GD.xs"
	{
		int color;
		if (items > 1) {
			color=(int)SvIV(ST(1));
			gdImageColorTransparent(image,color);
		}
		RETVAL = gdImageGetTransparent(image);
	}
#line 2032 "GD.c"
	XSprePUSH; PUSHi((IV)RETVAL);
    }
    XSRETURN(1);
}


XS_EUPXS(XS_GD__Image_getBounds); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_GD__Image_getBounds)
{
    dVAR; dXSARGS;
    if (items != 1)
       croak_xs_usage(cv,  "image");
    PERL_UNUSED_VAR(ax); /* -Wall */
    SP -= items;
    {
	GD__Image	image;

	if (SvROK(ST(0)) && sv_derived_from(ST(0), "GD::Image")) {
	    IV tmp = SvIV((SV*)SvRV(ST(0)));
	    image = INT2PTR(GD__Image,tmp);
	}
	else
	    Perl_croak_nocontext("%s: %s is not of type %s",
			"GD::Image::getBounds",
			"image", "GD::Image")
;
#line 1152 "GD.xs"
	{
		int sx,sy;
		sx = gdImageSX(image);
		sy = gdImageSY(image);
		EXTEND(sp,2);
		PUSHs(sv_2mortal(newSViv(sx)));
		PUSHs(sv_2mortal(newSViv(sy)));
	}
#line 2068 "GD.c"
	PUTBACK;
	return;
    }
}


XS_EUPXS(XS_GD__Image_isTrueColor); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_GD__Image_isTrueColor)
{
    dVAR; dXSARGS;
    if (items != 1)
       croak_xs_usage(cv,  "image");
    {
	GD__Image	image;
	int	RETVAL;
	dXSTARG;

	if (SvROK(ST(0)) && sv_derived_from(ST(0), "GD::Image")) {
	    IV tmp = SvIV((SV*)SvRV(ST(0)));
	    image = INT2PTR(GD__Image,tmp);
	}
	else
	    Perl_croak_nocontext("%s: %s is not of type %s",
			"GD::Image::isTrueColor",
			"image", "GD::Image")
;
#line 1166 "GD.xs"
	{
		RETVAL=gdImageTrueColor(image);
	}
#line 2099 "GD.c"
	XSprePUSH; PUSHi((IV)RETVAL);
    }
    XSRETURN(1);
}


XS_EUPXS(XS_GD__Image_trueColorToPalette); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_GD__Image_trueColorToPalette)
{
    dVAR; dXSARGS;
    if (items < 1 || items > 3)
       croak_xs_usage(cv,  "image, dither=0, colors=gdMaxColors");
    {
	GD__Image	image;
	int	dither;
	int	colors;

	if (SvROK(ST(0)) && sv_derived_from(ST(0), "GD::Image")) {
	    IV tmp = SvIV((SV*)SvRV(ST(0)));
	    image = INT2PTR(GD__Image,tmp);
	}
	else
	    Perl_croak_nocontext("%s: %s is not of type %s",
			"GD::Image::trueColorToPalette",
			"image", "GD::Image")
;

	if (items < 2)
	    dither = 0;
	else {
	    dither = (int)SvIV(ST(1))
;
	}

	if (items < 3)
	    colors = gdMaxColors;
	else {
	    colors = (int)SvIV(ST(2))
;
	}
#line 1179 "GD.xs"
	{
		gdImageTrueColorToPalette(image,dither,colors);
	}
#line 2144 "GD.c"
    }
    XSRETURN_EMPTY;
}


XS_EUPXS(XS_GD__Image_rgb); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_GD__Image_rgb)
{
    dVAR; dXSARGS;
    if (items != 2)
       croak_xs_usage(cv,  "image, color");
    PERL_UNUSED_VAR(ax); /* -Wall */
    SP -= items;
    {
	GD__Image	image;
	int	color = (int)SvIV(ST(1))
;

	if (SvROK(ST(0)) && sv_derived_from(ST(0), "GD::Image")) {
	    IV tmp = SvIV((SV*)SvRV(ST(0)));
	    image = INT2PTR(GD__Image,tmp);
	}
	else
	    Perl_croak_nocontext("%s: %s is not of type %s",
			"GD::Image::rgb",
			"image", "GD::Image")
;
#line 1189 "GD.xs"
	{
		int r,g,b;
		r = gdImageRed(image,color);
		g = gdImageGreen(image,color);
		b = gdImageBlue(image,color);
		EXTEND(sp,3);
		PUSHs(sv_2mortal(newSViv(r)));
		PUSHs(sv_2mortal(newSViv(g)));
		PUSHs(sv_2mortal(newSViv(b)));
	}
#line 2183 "GD.c"
	PUTBACK;
	return;
    }
}


XS_EUPXS(XS_GD__Image_boundsSafe); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_GD__Image_boundsSafe)
{
    dVAR; dXSARGS;
    if (items != 3)
       croak_xs_usage(cv,  "image, x, y");
    {
	GD__Image	image;
	int	x = (int)SvIV(ST(1))
;
	int	y = (int)SvIV(ST(2))
;
	int	RETVAL;
	dXSTARG;

	if (SvROK(ST(0)) && sv_derived_from(ST(0), "GD::Image")) {
	    IV tmp = SvIV((SV*)SvRV(ST(0)));
	    image = INT2PTR(GD__Image,tmp);
	}
	else
	    Perl_croak_nocontext("%s: %s is not of type %s",
			"GD::Image::boundsSafe",
			"image", "GD::Image")
;
#line 1207 "GD.xs"
	{
	  RETVAL=gdImageBoundsSafe(image,x,y);
	  if (RETVAL == 0)
	    XSRETURN_UNDEF;
	}
#line 2220 "GD.c"
	XSprePUSH; PUSHi((IV)RETVAL);
    }
    XSRETURN(1);
}


XS_EUPXS(XS_GD__Image_getPixel); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_GD__Image_getPixel)
{
    dVAR; dXSARGS;
    if (items != 3)
       croak_xs_usage(cv,  "image, x, y");
    {
	GD__Image	image;
	int	x = (int)SvIV(ST(1))
;
	int	y = (int)SvIV(ST(2))
;
	int	RETVAL;
	dXSTARG;

	if (SvROK(ST(0)) && sv_derived_from(ST(0), "GD::Image")) {
	    IV tmp = SvIV((SV*)SvRV(ST(0)));
	    image = INT2PTR(GD__Image,tmp);
	}
	else
	    Perl_croak_nocontext("%s: %s is not of type %s",
			"GD::Image::getPixel",
			"image", "GD::Image")
;
#line 1222 "GD.xs"
	{
		RETVAL=gdImageGetPixel(image,x,y);
	}
#line 2255 "GD.c"
	XSprePUSH; PUSHi((IV)RETVAL);
    }
    XSRETURN(1);
}


XS_EUPXS(XS_GD__Image_setPixel); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_GD__Image_setPixel)
{
    dVAR; dXSARGS;
    if (items != 4)
       croak_xs_usage(cv,  "image, x, y, color");
    {
	GD__Image	image;
	int	x = (int)SvIV(ST(1))
;
	int	y = (int)SvIV(ST(2))
;
	int	color = (int)SvIV(ST(3))
;

	if (SvROK(ST(0)) && sv_derived_from(ST(0), "GD::Image")) {
	    IV tmp = SvIV((SV*)SvRV(ST(0)));
	    image = INT2PTR(GD__Image,tmp);
	}
	else
	    Perl_croak_nocontext("%s: %s is not of type %s",
			"GD::Image::setPixel",
			"image", "GD::Image")
;
#line 1236 "GD.xs"
	{
		gdImageSetPixel(image,x,y,color);
	}
#line 2290 "GD.c"
    }
    XSRETURN_EMPTY;
}


XS_EUPXS(XS_GD__Image_copyRotate90); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_GD__Image_copyRotate90)
{
    dVAR; dXSARGS;
    if (items != 1)
       croak_xs_usage(cv,  "src");
    {
	GD__Image	src;
	GD__Image	RETVAL;

	if (SvROK(ST(0)) && sv_derived_from(ST(0), "GD::Image")) {
	    IV tmp = SvIV((SV*)SvRV(ST(0)));
	    src = INT2PTR(GD__Image,tmp);
	}
	else
	    Perl_croak_nocontext("%s: %s is not of type %s",
			"GD::Image::copyRotate90",
			"src", "GD::Image")
;
#line 1245 "GD.xs"
	{
		int x, y, x1, y1, x2, y2, i, j;
		GD__Image dst;
		get_xformbounds(src, &x, &y, &x1, &y1, &x2, &y2);
		dst = (GD__Image) gd_cloneDim(src, y, x);

		for (j=0;j<y;j++) {
		   for (i=0;i<x;i++) {
		      GDCopyImagePixel(dst,y1-j,i,src,i,j);
		   }
		}
		RETVAL = dst;
	}
#line 2329 "GD.c"
	{
	    SV * RETVALSV;
	    RETVALSV = sv_newmortal();
	    sv_setref_pv(RETVALSV, "GD::Image", (void*)RETVAL);
	    ST(0) = RETVALSV;
	}
    }
    XSRETURN(1);
}


XS_EUPXS(XS_GD__Image_copyRotate180); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_GD__Image_copyRotate180)
{
    dVAR; dXSARGS;
    if (items != 1)
       croak_xs_usage(cv,  "src");
    {
	GD__Image	src;
	GD__Image	RETVAL;

	if (SvROK(ST(0)) && sv_derived_from(ST(0), "GD::Image")) {
	    IV tmp = SvIV((SV*)SvRV(ST(0)));
	    src = INT2PTR(GD__Image,tmp);
	}
	else
	    Perl_croak_nocontext("%s: %s is not of type %s",
			"GD::Image::copyRotate180",
			"src", "GD::Image")
;
#line 1266 "GD.xs"
	{
		int x, y, x1, y1, x2, y2, i, j;
		GD__Image dst;
		get_xformbounds(src, &x, &y, &x1, &y1, &x2, &y2);
		dst = (GD__Image) gd_cloneDim(src, x, y);

		for (j=0;j<y;j++) {
		   for (i=0;i<x;i++) {
		      GDCopyImagePixel(dst,x1-i,y1-j,src,i,j);
		   }
		}
		RETVAL = dst;
	}
#line 2374 "GD.c"
	{
	    SV * RETVALSV;
	    RETVALSV = sv_newmortal();
	    sv_setref_pv(RETVALSV, "GD::Image", (void*)RETVAL);
	    ST(0) = RETVALSV;
	}
    }
    XSRETURN(1);
}


XS_EUPXS(XS_GD__Image_copyRotate270); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_GD__Image_copyRotate270)
{
    dVAR; dXSARGS;
    if (items != 1)
       croak_xs_usage(cv,  "src");
    {
	GD__Image	src;
	GD__Image	RETVAL;

	if (SvROK(ST(0)) && sv_derived_from(ST(0), "GD::Image")) {
	    IV tmp = SvIV((SV*)SvRV(ST(0)));
	    src = INT2PTR(GD__Image,tmp);
	}
	else
	    Perl_croak_nocontext("%s: %s is not of type %s",
			"GD::Image::copyRotate270",
			"src", "GD::Image")
;
#line 1287 "GD.xs"
	{
		int x, y, x1, y1, x2, y2, i, j;
		GD__Image dst;
		get_xformbounds(src, &x, &y, &x1, &y1, &x2, &y2);
		dst = (GD__Image) gd_cloneDim(src, y, x);

		for (i=0;i<x;i++) {
		   for (j=0;j<y;j++) {
		      GDCopyImagePixel(dst,j,x1-i,src,i,j);
		   }
		}
		RETVAL = dst;
	}
#line 2419 "GD.c"
	{
	    SV * RETVALSV;
	    RETVALSV = sv_newmortal();
	    sv_setref_pv(RETVALSV, "GD::Image", (void*)RETVAL);
	    ST(0) = RETVALSV;
	}
    }
    XSRETURN(1);
}


XS_EUPXS(XS_GD__Image_copyFlipHorizontal); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_GD__Image_copyFlipHorizontal)
{
    dVAR; dXSARGS;
    if (items != 1)
       croak_xs_usage(cv,  "src");
    {
	GD__Image	src;
	GD__Image	RETVAL;

	if (SvROK(ST(0)) && sv_derived_from(ST(0), "GD::Image")) {
	    IV tmp = SvIV((SV*)SvRV(ST(0)));
	    src = INT2PTR(GD__Image,tmp);
	}
	else
	    Perl_croak_nocontext("%s: %s is not of type %s",
			"GD::Image::copyFlipHorizontal",
			"src", "GD::Image")
;
#line 1308 "GD.xs"
	{
		int x, y, x1, y1, x2, y2, i, j;
		GD__Image dst;
		get_xformbounds(src, &x, &y, &x1, &y1, &x2, &y2);
		dst = (GD__Image) gd_cloneDim(src, x, y);

		for (j=0;j<y;j++) {
		   for (i=0;i<x;i++) {
		      GDCopyImagePixel(dst,x1-i,j,src,i,j);
		   }
		}
		RETVAL = dst;
	}
#line 2464 "GD.c"
	{
	    SV * RETVALSV;
	    RETVALSV = sv_newmortal();
	    sv_setref_pv(RETVALSV, "GD::Image", (void*)RETVAL);
	    ST(0) = RETVALSV;
	}
    }
    XSRETURN(1);
}


XS_EUPXS(XS_GD__Image_copyFlipVertical); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_GD__Image_copyFlipVertical)
{
    dVAR; dXSARGS;
    if (items != 1)
       croak_xs_usage(cv,  "src");
    {
	GD__Image	src;
	GD__Image	RETVAL;

	if (SvROK(ST(0)) && sv_derived_from(ST(0), "GD::Image")) {
	    IV tmp = SvIV((SV*)SvRV(ST(0)));
	    src = INT2PTR(GD__Image,tmp);
	}
	else
	    Perl_croak_nocontext("%s: %s is not of type %s",
			"GD::Image::copyFlipVertical",
			"src", "GD::Image")
;
#line 1329 "GD.xs"
	{
		int x, y, x1, y1, x2, y2, i, j;
		GD__Image dst;
		get_xformbounds(src, &x, &y, &x1, &y1, &x2, &y2);
		dst = (GD__Image) gd_cloneDim(src, x, y);

		for (j=0;j<y;j++) {
		   for (i=0;i<x;i++) {
		      GDCopyImagePixel(dst,i,y1-j,src,i,j);
		   }
		}
		RETVAL = dst;
	}
#line 2509 "GD.c"
	{
	    SV * RETVALSV;
	    RETVALSV = sv_newmortal();
	    sv_setref_pv(RETVALSV, "GD::Image", (void*)RETVAL);
	    ST(0) = RETVALSV;
	}
    }
    XSRETURN(1);
}


XS_EUPXS(XS_GD__Image_copyTranspose); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_GD__Image_copyTranspose)
{
    dVAR; dXSARGS;
    if (items != 1)
       croak_xs_usage(cv,  "src");
    {
	GD__Image	src;
	GD__Image	RETVAL;

	if (SvROK(ST(0)) && sv_derived_from(ST(0), "GD::Image")) {
	    IV tmp = SvIV((SV*)SvRV(ST(0)));
	    src = INT2PTR(GD__Image,tmp);
	}
	else
	    Perl_croak_nocontext("%s: %s is not of type %s",
			"GD::Image::copyTranspose",
			"src", "GD::Image")
;
#line 1350 "GD.xs"
	{
		int x, y, x1, y1, x2, y2, i, j;
		GD__Image dst;
		get_xformbounds(src, &x, &y, &x1, &y1, &x2, &y2);
		dst = (GD__Image) gd_cloneDim(src, y, x);

		for (j=0;j<y;j++) {
		   for (i=0;i<x;i++) {
		      GDCopyImagePixel(dst,j,i,src,i,j);
		   }
		}
		RETVAL = dst;
	}
#line 2554 "GD.c"
	{
	    SV * RETVALSV;
	    RETVALSV = sv_newmortal();
	    sv_setref_pv(RETVALSV, "GD::Image", (void*)RETVAL);
	    ST(0) = RETVALSV;
	}
    }
    XSRETURN(1);
}


XS_EUPXS(XS_GD__Image_copyReverseTranspose); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_GD__Image_copyReverseTranspose)
{
    dVAR; dXSARGS;
    if (items != 1)
       croak_xs_usage(cv,  "src");
    {
	GD__Image	src;
	GD__Image	RETVAL;

	if (SvROK(ST(0)) && sv_derived_from(ST(0), "GD::Image")) {
	    IV tmp = SvIV((SV*)SvRV(ST(0)));
	    src = INT2PTR(GD__Image,tmp);
	}
	else
	    Perl_croak_nocontext("%s: %s is not of type %s",
			"GD::Image::copyReverseTranspose",
			"src", "GD::Image")
;
#line 1371 "GD.xs"
	{
		int x, y, x1, y1, x2, y2, i, j;
		GD__Image dst;
		get_xformbounds(src, &x, &y, &x1, &y1, &x2, &y2);
		dst = (GD__Image) gd_cloneDim(src, y, x);

		for (j=0;j<y;j++) {
		   for (i=0;i<x;i++) {
		      GDCopyImagePixel(dst,y1-j,x1-i,src,i,j);
		   }
		}
		RETVAL = dst;
	}
#line 2599 "GD.c"
	{
	    SV * RETVALSV;
	    RETVALSV = sv_newmortal();
	    sv_setref_pv(RETVALSV, "GD::Image", (void*)RETVAL);
	    ST(0) = RETVALSV;
	}
    }
    XSRETURN(1);
}


XS_EUPXS(XS_GD__Image_rotate180); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_GD__Image_rotate180)
{
    dVAR; dXSARGS;
    if (items != 1)
       croak_xs_usage(cv,  "src");
    {
	GD__Image	src;

	if (SvROK(ST(0)) && sv_derived_from(ST(0), "GD::Image")) {
	    IV tmp = SvIV((SV*)SvRV(ST(0)));
	    src = INT2PTR(GD__Image,tmp);
	}
	else
	    Perl_croak_nocontext("%s: %s is not of type %s",
			"GD::Image::rotate180",
			"src", "GD::Image")
;
#line 1392 "GD.xs"
	{
		int x, y, x1, y1, x2, y2, i, j, tmp;
		get_xformbounds(src, &x, &y, &x1, &y1, &x2, &y2);

		for (j=0;j<y2;j++) {
		   for (i=0;i<x;i++) {
		      tmp = GDGetImagePixel(src,x1-i,y1-j);
		      GDCopyImagePixel(src,x1-i,y1-j,src,i,j);
		      GDSetImagePixel(src,i,j,tmp);
		   }
		}
	}
#line 2642 "GD.c"
    }
    XSRETURN_EMPTY;
}


XS_EUPXS(XS_GD__Image_copyRotated); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_GD__Image_copyRotated)
{
    dVAR; dXSARGS;
    if (items != 9)
       croak_xs_usage(cv,  "dst, src, dstX, dstY, srcX, srcY, srcW, srcH, angle");
    {
	GD__Image	dst;
	GD__Image	src;
	double	dstX = (double)SvNV(ST(2))
;
	double	dstY = (double)SvNV(ST(3))
;
	int	srcX = (int)SvIV(ST(4))
;
	int	srcY = (int)SvIV(ST(5))
;
	int	srcW = (int)SvIV(ST(6))
;
	int	srcH = (int)SvIV(ST(7))
;
	int	angle = (int)SvIV(ST(8))
;

	if (SvROK(ST(0)) && sv_derived_from(ST(0), "GD::Image")) {
	    IV tmp = SvIV((SV*)SvRV(ST(0)));
	    dst = INT2PTR(GD__Image,tmp);
	}
	else
	    Perl_croak_nocontext("%s: %s is not of type %s",
			"GD::Image::copyRotated",
			"dst", "GD::Image")
;

	if (SvROK(ST(1)) && sv_derived_from(ST(1), "GD::Image")) {
	    IV tmp = SvIV((SV*)SvRV(ST(1)));
	    src = INT2PTR(GD__Image,tmp);
	}
	else
	    Perl_croak_nocontext("%s: %s is not of type %s",
			"GD::Image::copyRotated",
			"src", "GD::Image")
;
#line 1418 "GD.xs"
	{
#ifdef VERSION_33
        gdImageCopyRotated(dst,src,dstX,dstY,srcX,srcY,srcW,srcH,angle);
#else
        die("libgd 2.0.33 or higher required for copyRotated support");
#endif
	}
#line 2699 "GD.c"
    }
    XSRETURN_EMPTY;
}


XS_EUPXS(XS_GD__Image_flipHorizontal); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_GD__Image_flipHorizontal)
{
    dVAR; dXSARGS;
    if (items != 1)
       croak_xs_usage(cv,  "src");
    {
	GD__Image	src;

	if (SvROK(ST(0)) && sv_derived_from(ST(0), "GD::Image")) {
	    IV tmp = SvIV((SV*)SvRV(ST(0)));
	    src = INT2PTR(GD__Image,tmp);
	}
	else
	    Perl_croak_nocontext("%s: %s is not of type %s",
			"GD::Image::flipHorizontal",
			"src", "GD::Image")
;
#line 1431 "GD.xs"
	{
		int x, y, x1, y1, x2, y2, i, j, tmp;
		get_xformbounds(src, &x, &y, &x1, &y1, &x2, &y2);

		for (j=0;j<y;j++) {
		   for (i=0;i<x2;i++) {
		      tmp = GDGetImagePixel(src,x1-i,j);
		      GDCopyImagePixel(src,x1-i,j,src,i,j);
		      GDSetImagePixel(src,i,j,tmp);
		   }
		}
	}
#line 2736 "GD.c"
    }
    XSRETURN_EMPTY;
}


XS_EUPXS(XS_GD__Image_flipVertical); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_GD__Image_flipVertical)
{
    dVAR; dXSARGS;
    if (items != 1)
       croak_xs_usage(cv,  "src");
    {
	GD__Image	src;

	if (SvROK(ST(0)) && sv_derived_from(ST(0), "GD::Image")) {
	    IV tmp = SvIV((SV*)SvRV(ST(0)));
	    src = INT2PTR(GD__Image,tmp);
	}
	else
	    Perl_croak_nocontext("%s: %s is not of type %s",
			"GD::Image::flipVertical",
			"src", "GD::Image")
;
#line 1449 "GD.xs"
	{
		int x, y, x1, y1, x2, y2, i, j, tmp;
		get_xformbounds(src, &x, &y, &x1, &y1, &x2, &y2);

		for (j=0;j<y2;j++) {
		   for (i=0;i<x;i++) {
		      tmp = GDGetImagePixel(src,i,y1-j);
		      GDCopyImagePixel(src,i,y1-j,src,i,j);
		      GDSetImagePixel(src,i,j,tmp);
		   }
		}
	}
#line 2773 "GD.c"
    }
    XSRETURN_EMPTY;
}


XS_EUPXS(XS_GD__Image_line); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_GD__Image_line)
{
    dVAR; dXSARGS;
    if (items != 6)
       croak_xs_usage(cv,  "image, x1, y1, x2, y2, color");
    {
	GD__Image	image;
	int	x1 = (int)SvIV(ST(1))
;
	int	y1 = (int)SvIV(ST(2))
;
	int	x2 = (int)SvIV(ST(3))
;
	int	y2 = (int)SvIV(ST(4))
;
	int	color = (int)SvIV(ST(5))
;

	if (SvROK(ST(0)) && sv_derived_from(ST(0), "GD::Image")) {
	    IV tmp = SvIV((SV*)SvRV(ST(0)));
	    image = INT2PTR(GD__Image,tmp);
	}
	else
	    Perl_croak_nocontext("%s: %s is not of type %s",
			"GD::Image::line",
			"image", "GD::Image")
;
#line 1472 "GD.xs"
	{
		gdImageLine(image,x1,y1,x2,y2,color);
	}
#line 2811 "GD.c"
    }
    XSRETURN_EMPTY;
}


XS_EUPXS(XS_GD__Image_dashedLine); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_GD__Image_dashedLine)
{
    dVAR; dXSARGS;
    if (items != 6)
       croak_xs_usage(cv,  "image, x1, y1, x2, y2, color");
    {
	GD__Image	image;
	int	x1 = (int)SvIV(ST(1))
;
	int	y1 = (int)SvIV(ST(2))
;
	int	x2 = (int)SvIV(ST(3))
;
	int	y2 = (int)SvIV(ST(4))
;
	int	color = (int)SvIV(ST(5))
;

	if (SvROK(ST(0)) && sv_derived_from(ST(0), "GD::Image")) {
	    IV tmp = SvIV((SV*)SvRV(ST(0)));
	    image = INT2PTR(GD__Image,tmp);
	}
	else
	    Perl_croak_nocontext("%s: %s is not of type %s",
			"GD::Image::dashedLine",
			"image", "GD::Image")
;
#line 1486 "GD.xs"
	{
		gdImageDashedLine(image,x1,y1,x2,y2,color);
	}
#line 2849 "GD.c"
    }
    XSRETURN_EMPTY;
}


XS_EUPXS(XS_GD__Image_openPolygon); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_GD__Image_openPolygon)
{
    dVAR; dXSARGS;
    if (items != 3)
       croak_xs_usage(cv,  "image, poly, color");
    {
	GD__Image	image;
	SV *	poly = ST(1)
;
	int	color = (int)SvIV(ST(2))
;

	if (SvROK(ST(0)) && sv_derived_from(ST(0), "GD::Image")) {
	    IV tmp = SvIV((SV*)SvRV(ST(0)));
	    image = INT2PTR(GD__Image,tmp);
	}
	else
	    Perl_croak_nocontext("%s: %s is not of type %s",
			"GD::Image::openPolygon",
			"image", "GD::Image")
;
#line 1497 "GD.xs"
	{
		dSP ;
		int length,count ;
		int x,y,i ;
		gdPointPtr polyptr;

		ENTER ;
		SAVETMPS ;
		PUSHMARK(sp) ;
		XPUSHs(poly) ;
		PUTBACK ;
		count = perl_call_method("length",G_SCALAR) ;
		SPAGAIN ;
		if (count != 1)
			croak("Didn't get a single result from GD::Poly::length() call.\n");
		length = POPi ;
		PUTBACK ;
		FREETMPS ;
		LEAVE ;

		polyptr = (gdPointPtr)safemalloc(sizeof(gdPoint)*length);
		if (polyptr == NULL)
			croak("safemalloc() returned NULL in GD::Image::poly().\n");

		for (i=0;i<length;i++) {
			ENTER ;
			SAVETMPS ;
			PUSHMARK(sp) ;
			XPUSHs(poly) ;
			XPUSHs(sv_2mortal(newSViv(i))) ;
			PUTBACK ;
			count = perl_call_method("getPt",G_ARRAY) ;
			SPAGAIN ;
			if (count != 2)
				croak("Didn't get a single result from GD::Poly::length() call.\n");
			y = POPi ;
			x = POPi ;
			PUTBACK ;
			FREETMPS ;
			LEAVE ;

			polyptr[i].x = x;
			polyptr[i].y = y;
		}

		gdImagePolygon(image,polyptr,length,color);
		safefree((char*) polyptr);
	}
#line 2926 "GD.c"
    }
    XSRETURN_EMPTY;
}


XS_EUPXS(XS_GD__Image_unclosedPolygon); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_GD__Image_unclosedPolygon)
{
    dVAR; dXSARGS;
    if (items != 3)
       croak_xs_usage(cv,  "image, poly, color");
    {
	GD__Image	image;
	SV *	poly = ST(1)
;
	int	color = (int)SvIV(ST(2))
;

	if (SvROK(ST(0)) && sv_derived_from(ST(0), "GD::Image")) {
	    IV tmp = SvIV((SV*)SvRV(ST(0)));
	    image = INT2PTR(GD__Image,tmp);
	}
	else
	    Perl_croak_nocontext("%s: %s is not of type %s",
			"GD::Image::unclosedPolygon",
			"image", "GD::Image")
;
#line 1553 "GD.xs"
	{
		dSP ;
		int length,count ;
		int x,y,i ;
		gdPointPtr polyptr;
#ifdef HAVE_UNCLOSEDPOLY
		ENTER ;
		SAVETMPS ;
		PUSHMARK(sp) ;
		XPUSHs(poly) ;
		PUTBACK ;
		count = perl_call_method("length",G_SCALAR) ;
		SPAGAIN ;
		if (count != 1)
			croak("Didn't get a single result from GD::Poly::length() call.\n");
		length = POPi ;
		PUTBACK ;
		FREETMPS ;
		LEAVE ;

		polyptr = (gdPointPtr)safemalloc(sizeof(gdPoint)*length);
		if (polyptr == NULL)
			croak("safemalloc() returned NULL in GD::Image::poly().\n");

		for (i=0;i<length;i++) {
			ENTER ;
			SAVETMPS ;
			PUSHMARK(sp) ;
			XPUSHs(poly) ;
			XPUSHs(sv_2mortal(newSViv(i))) ;
			PUTBACK ;
			count = perl_call_method("getPt",G_ARRAY) ;
			SPAGAIN ;
			if (count != 2)
				croak("Didn't get a single result from GD::Poly::length() call.\n");
			y = POPi ;
			x = POPi ;
			PUTBACK ;
			FREETMPS ;
			LEAVE ;

			polyptr[i].x = x;
			polyptr[i].y = y;
		}

		gdImageOpenPolygon(image,polyptr,length,color);
		safefree((char*) polyptr);
#else
	die("libgd 2.0.33 or higher required for unclosed polygon support");
#endif
	}
#line 3006 "GD.c"
    }
    XSRETURN_EMPTY;
}


XS_EUPXS(XS_GD__Image_filledPolygon); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_GD__Image_filledPolygon)
{
    dVAR; dXSARGS;
    if (items != 3)
       croak_xs_usage(cv,  "image, poly, color");
    {
	GD__Image	image;
	SV *	poly = ST(1)
;
	int	color = (int)SvIV(ST(2))
;

	if (SvROK(ST(0)) && sv_derived_from(ST(0), "GD::Image")) {
	    IV tmp = SvIV((SV*)SvRV(ST(0)));
	    image = INT2PTR(GD__Image,tmp);
	}
	else
	    Perl_croak_nocontext("%s: %s is not of type %s",
			"GD::Image::filledPolygon",
			"image", "GD::Image")
;
#line 1612 "GD.xs"
	{
		dSP ;
		int length,count ;
		int x,y,i ;
		gdPointPtr polyptr;

		ENTER ;
		SAVETMPS ;
		PUSHMARK(sp) ;
		XPUSHs(poly) ;
		PUTBACK ;
		count = perl_call_method("length",G_SCALAR) ;
		SPAGAIN ;
		if (count != 1)
			croak("Didn't get a single result from GD::Poly::length() call.\n");
		length = POPi ;
		PUTBACK ;
		FREETMPS ;
		LEAVE ;

		polyptr = (gdPointPtr)safemalloc(sizeof(gdPoint)*length);
		if (polyptr == NULL)
			croak("safemalloc() returned NULL in GD::Image::poly().\n");

		for (i=0;i<length;i++) {
			ENTER ;
			SAVETMPS ;
			PUSHMARK(sp) ;
			XPUSHs(poly) ;
			XPUSHs(sv_2mortal(newSViv(i))) ;
			PUTBACK ;
			count = perl_call_method("getPt",G_ARRAY) ;
			SPAGAIN ;
			if (count != 2)
				croak("Didn't get a single result from GD::Poly::length() call.\n");
			y = POPi ;
			x = POPi ;
			PUTBACK ;
			FREETMPS ;
			LEAVE ;

			polyptr[i].x = x;
			polyptr[i].y = y;
		}

		gdImageFilledPolygon(image,polyptr,length,color);
		safefree((char*) polyptr);
	}
#line 3083 "GD.c"
    }
    XSRETURN_EMPTY;
}


XS_EUPXS(XS_GD__Image_rectangle); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_GD__Image_rectangle)
{
    dVAR; dXSARGS;
    if (items != 6)
       croak_xs_usage(cv,  "image, x1, y1, x2, y2, color");
    {
	GD__Image	image;
	int	x1 = (int)SvIV(ST(1))
;
	int	y1 = (int)SvIV(ST(2))
;
	int	x2 = (int)SvIV(ST(3))
;
	int	y2 = (int)SvIV(ST(4))
;
	int	color = (int)SvIV(ST(5))
;

	if (SvROK(ST(0)) && sv_derived_from(ST(0), "GD::Image")) {
	    IV tmp = SvIV((SV*)SvRV(ST(0)));
	    image = INT2PTR(GD__Image,tmp);
	}
	else
	    Perl_croak_nocontext("%s: %s is not of type %s",
			"GD::Image::rectangle",
			"image", "GD::Image")
;
#line 1671 "GD.xs"
	{
		gdImageRectangle(image,x1,y1,x2,y2,color);
	}
#line 3121 "GD.c"
    }
    XSRETURN_EMPTY;
}


XS_EUPXS(XS_GD__Image_filledRectangle); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_GD__Image_filledRectangle)
{
    dVAR; dXSARGS;
    if (items != 6)
       croak_xs_usage(cv,  "image, x1, y1, x2, y2, color");
    {
	GD__Image	image;
	int	x1 = (int)SvIV(ST(1))
;
	int	y1 = (int)SvIV(ST(2))
;
	int	x2 = (int)SvIV(ST(3))
;
	int	y2 = (int)SvIV(ST(4))
;
	int	color = (int)SvIV(ST(5))
;

	if (SvROK(ST(0)) && sv_derived_from(ST(0), "GD::Image")) {
	    IV tmp = SvIV((SV*)SvRV(ST(0)));
	    image = INT2PTR(GD__Image,tmp);
	}
	else
	    Perl_croak_nocontext("%s: %s is not of type %s",
			"GD::Image::filledRectangle",
			"image", "GD::Image")
;
#line 1685 "GD.xs"
	{
		gdImageFilledRectangle(image,x1,y1,x2,y2,color);
	}
#line 3159 "GD.c"
    }
    XSRETURN_EMPTY;
}


XS_EUPXS(XS_GD__Image_filledEllipse); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_GD__Image_filledEllipse)
{
    dVAR; dXSARGS;
    if (items != 6)
       croak_xs_usage(cv,  "image, cx, cy, w, h, color");
    {
	GD__Image	image;
	int	cx = (int)SvIV(ST(1))
;
	int	cy = (int)SvIV(ST(2))
;
	int	w = (int)SvIV(ST(3))
;
	int	h = (int)SvIV(ST(4))
;
	int	color = (int)SvIV(ST(5))
;

	if (SvROK(ST(0)) && sv_derived_from(ST(0), "GD::Image")) {
	    IV tmp = SvIV((SV*)SvRV(ST(0)));
	    image = INT2PTR(GD__Image,tmp);
	}
	else
	    Perl_croak_nocontext("%s: %s is not of type %s",
			"GD::Image::filledEllipse",
			"image", "GD::Image")
;
#line 1699 "GD.xs"
	{
		gdImageFilledEllipse(image,cx,cy,w,h,color);
	}
#line 3197 "GD.c"
    }
    XSRETURN_EMPTY;
}


XS_EUPXS(XS_GD__Image_arc); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_GD__Image_arc)
{
    dVAR; dXSARGS;
    if (items != 8)
       croak_xs_usage(cv,  "image, cx, cy, w, h, s, e, color");
    {
	GD__Image	image;
	int	cx = (int)SvIV(ST(1))
;
	int	cy = (int)SvIV(ST(2))
;
	int	w = (int)SvIV(ST(3))
;
	int	h = (int)SvIV(ST(4))
;
	int	s = (int)SvIV(ST(5))
;
	int	e = (int)SvIV(ST(6))
;
	int	color = (int)SvIV(ST(7))
;

	if (SvROK(ST(0)) && sv_derived_from(ST(0), "GD::Image")) {
	    IV tmp = SvIV((SV*)SvRV(ST(0)));
	    image = INT2PTR(GD__Image,tmp);
	}
	else
	    Perl_croak_nocontext("%s: %s is not of type %s",
			"GD::Image::arc",
			"image", "GD::Image")
;
#line 1715 "GD.xs"
	{
		gdImageArc(image,cx,cy,w,h,s,e,color);
	}
#line 3239 "GD.c"
    }
    XSRETURN_EMPTY;
}


XS_EUPXS(XS_GD__Image_filledArc); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_GD__Image_filledArc)
{
    dVAR; dXSARGS;
    if (items < 8 || items > 9)
       croak_xs_usage(cv,  "image, cx, cy, w, h, s, e, color, arc_style=0");
    {
	GD__Image	image;
	int	cx = (int)SvIV(ST(1))
;
	int	cy = (int)SvIV(ST(2))
;
	int	w = (int)SvIV(ST(3))
;
	int	h = (int)SvIV(ST(4))
;
	int	s = (int)SvIV(ST(5))
;
	int	e = (int)SvIV(ST(6))
;
	int	color = (int)SvIV(ST(7))
;
	int	arc_style;

	if (SvROK(ST(0)) && sv_derived_from(ST(0), "GD::Image")) {
	    IV tmp = SvIV((SV*)SvRV(ST(0)));
	    image = INT2PTR(GD__Image,tmp);
	}
	else
	    Perl_croak_nocontext("%s: %s is not of type %s",
			"GD::Image::filledArc",
			"image", "GD::Image")
;

	if (items < 9)
	    arc_style = 0;
	else {
	    arc_style = (int)SvIV(ST(8))
;
	}
#line 1732 "GD.xs"
	{
		gdImageFilledArc(image,cx,cy,w,h,s,e,color,arc_style);
	}
#line 3289 "GD.c"
    }
    XSRETURN_EMPTY;
}


XS_EUPXS(XS_GD__Image_fillToBorder); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_GD__Image_fillToBorder)
{
    dVAR; dXSARGS;
    if (items != 5)
       croak_xs_usage(cv,  "image, x, y, border, color");
    {
	GD__Image	image;
	int	x = (int)SvIV(ST(1))
;
	int	y = (int)SvIV(ST(2))
;
	int	border = (int)SvIV(ST(3))
;
	int	color = (int)SvIV(ST(4))
;

	if (SvROK(ST(0)) && sv_derived_from(ST(0), "GD::Image")) {
	    IV tmp = SvIV((SV*)SvRV(ST(0)));
	    image = INT2PTR(GD__Image,tmp);
	}
	else
	    Perl_croak_nocontext("%s: %s is not of type %s",
			"GD::Image::fillToBorder",
			"image", "GD::Image")
;
#line 1745 "GD.xs"
	{
		gdImageFillToBorder(image,x,y,border,color);
	}
#line 3325 "GD.c"
    }
    XSRETURN_EMPTY;
}


XS_EUPXS(XS_GD__Image_fill); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_GD__Image_fill)
{
    dVAR; dXSARGS;
    if (items != 4)
       croak_xs_usage(cv,  "image, x, y, color");
    {
	GD__Image	image;
	int	x = (int)SvIV(ST(1))
;
	int	y = (int)SvIV(ST(2))
;
	int	color = (int)SvIV(ST(3))
;

	if (SvROK(ST(0)) && sv_derived_from(ST(0), "GD::Image")) {
	    IV tmp = SvIV((SV*)SvRV(ST(0)));
	    image = INT2PTR(GD__Image,tmp);
	}
	else
	    Perl_croak_nocontext("%s: %s is not of type %s",
			"GD::Image::fill",
			"image", "GD::Image")
;
#line 1757 "GD.xs"
	{
		gdImageFill(image,x,y,color);
	}
#line 3359 "GD.c"
    }
    XSRETURN_EMPTY;
}


XS_EUPXS(XS_GD__Image_setBrush); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_GD__Image_setBrush)
{
    dVAR; dXSARGS;
    if (items != 2)
       croak_xs_usage(cv,  "image, brush");
    {
	GD__Image	image;
	GD__Image	brush;

	if (SvROK(ST(0)) && sv_derived_from(ST(0), "GD::Image")) {
	    IV tmp = SvIV((SV*)SvRV(ST(0)));
	    image = INT2PTR(GD__Image,tmp);
	}
	else
	    Perl_croak_nocontext("%s: %s is not of type %s",
			"GD::Image::setBrush",
			"image", "GD::Image")
;

	if (SvROK(ST(1)) && sv_derived_from(ST(1), "GD::Image")) {
	    IV tmp = SvIV((SV*)SvRV(ST(1)));
	    brush = INT2PTR(GD__Image,tmp);
	}
	else
	    Perl_croak_nocontext("%s: %s is not of type %s",
			"GD::Image::setBrush",
			"brush", "GD::Image")
;
#line 1767 "GD.xs"
	{
		gdImageSetBrush(image,brush);
	}
#line 3398 "GD.c"
    }
    XSRETURN_EMPTY;
}


XS_EUPXS(XS_GD__Image_setTile); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_GD__Image_setTile)
{
    dVAR; dXSARGS;
    if (items != 2)
       croak_xs_usage(cv,  "image, tile");
    {
	GD__Image	image;
	GD__Image	tile;

	if (SvROK(ST(0)) && sv_derived_from(ST(0), "GD::Image")) {
	    IV tmp = SvIV((SV*)SvRV(ST(0)));
	    image = INT2PTR(GD__Image,tmp);
	}
	else
	    Perl_croak_nocontext("%s: %s is not of type %s",
			"GD::Image::setTile",
			"image", "GD::Image")
;

	if (SvROK(ST(1)) && sv_derived_from(ST(1), "GD::Image")) {
	    IV tmp = SvIV((SV*)SvRV(ST(1)));
	    tile = INT2PTR(GD__Image,tmp);
	}
	else
	    Perl_croak_nocontext("%s: %s is not of type %s",
			"GD::Image::setTile",
			"tile", "GD::Image")
;
#line 1777 "GD.xs"
	{
		gdImageSetTile(image,tile);
	}
#line 3437 "GD.c"
    }
    XSRETURN_EMPTY;
}


XS_EUPXS(XS_GD__Image_setThickness); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_GD__Image_setThickness)
{
    dVAR; dXSARGS;
    if (items != 2)
       croak_xs_usage(cv,  "image, thickness");
    {
	GD__Image	image;
	int	thickness = (int)SvIV(ST(1))
;

	if (SvROK(ST(0)) && sv_derived_from(ST(0), "GD::Image")) {
	    IV tmp = SvIV((SV*)SvRV(ST(0)));
	    image = INT2PTR(GD__Image,tmp);
	}
	else
	    Perl_croak_nocontext("%s: %s is not of type %s",
			"GD::Image::setThickness",
			"image", "GD::Image")
;
#line 1787 "GD.xs"
	{
	  gdImageSetThickness(image,thickness);
	}
#line 3467 "GD.c"
    }
    XSRETURN_EMPTY;
}


XS_EUPXS(XS_GD__Image_setStyle); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_GD__Image_setStyle)
{
    dVAR; dXSARGS;
    if (items < 1)
       croak_xs_usage(cv,  "image, ...");
    {
	GD__Image	image;

	if (SvROK(ST(0)) && sv_derived_from(ST(0), "GD::Image")) {
	    IV tmp = SvIV((SV*)SvRV(ST(0)));
	    image = INT2PTR(GD__Image,tmp);
	}
	else
	    Perl_croak_nocontext("%s: %s is not of type %s",
			"GD::Image::setStyle",
			"image", "GD::Image")
;
#line 1797 "GD.xs"
	{
		int	*style;
		int	i;

		if (items < 2)
			return;
		style = (int*) safemalloc(sizeof(int)*(items-1));
		if (style == NULL)
			croak("malloc returned NULL at setStyle().\n");
		for(i=1;i<items;i++) {
			style[i-1]=(int)SvIV(ST(i));
		}
		gdImageSetStyle(image,style,items-1);
		safefree((char*) style);
	}
#line 3507 "GD.c"
    }
    XSRETURN_EMPTY;
}


XS_EUPXS(XS_GD__Image_colorAllocate); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_GD__Image_colorAllocate)
{
    dVAR; dXSARGS;
    if (items != 4)
       croak_xs_usage(cv,  "image, r, g, b");
    {
	GD__Image	image;
	int	r = (int)SvIV(ST(1))
;
	int	g = (int)SvIV(ST(2))
;
	int	b = (int)SvIV(ST(3))
;
	int	RETVAL;
	dXSTARG;

	if (SvROK(ST(0)) && sv_derived_from(ST(0), "GD::Image")) {
	    IV tmp = SvIV((SV*)SvRV(ST(0)));
	    image = INT2PTR(GD__Image,tmp);
	}
	else
	    Perl_croak_nocontext("%s: %s is not of type %s",
			"GD::Image::colorAllocate",
			"image", "GD::Image")
;
#line 1821 "GD.xs"
	{
		RETVAL = gdImageColorAllocate(image,r,g,b);
	}
#line 3543 "GD.c"
	XSprePUSH; PUSHi((IV)RETVAL);
    }
    XSRETURN(1);
}


XS_EUPXS(XS_GD__Image_colorAllocateAlpha); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_GD__Image_colorAllocateAlpha)
{
    dVAR; dXSARGS;
    if (items != 5)
       croak_xs_usage(cv,  "image, r, g, b, a");
    {
	GD__Image	image;
	int	r = (int)SvIV(ST(1))
;
	int	g = (int)SvIV(ST(2))
;
	int	b = (int)SvIV(ST(3))
;
	int	a = (int)SvIV(ST(4))
;
	int	RETVAL;
	dXSTARG;

	if (SvROK(ST(0)) && sv_derived_from(ST(0), "GD::Image")) {
	    IV tmp = SvIV((SV*)SvRV(ST(0)));
	    image = INT2PTR(GD__Image,tmp);
	}
	else
	    Perl_croak_nocontext("%s: %s is not of type %s",
			"GD::Image::colorAllocateAlpha",
			"image", "GD::Image")
;
#line 1836 "GD.xs"
	{
		RETVAL = gdImageColorAllocateAlpha(image,r,g,b,a);
	}
#line 3582 "GD.c"
	XSprePUSH; PUSHi((IV)RETVAL);
    }
    XSRETURN(1);
}


XS_EUPXS(XS_GD__Image_colorClosest); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_GD__Image_colorClosest)
{
    dVAR; dXSARGS;
    if (items != 4)
       croak_xs_usage(cv,  "image, r, g, b");
    {
	GD__Image	image;
	int	r = (int)SvIV(ST(1))
;
	int	g = (int)SvIV(ST(2))
;
	int	b = (int)SvIV(ST(3))
;
	int	RETVAL;
	dXSTARG;

	if (SvROK(ST(0)) && sv_derived_from(ST(0), "GD::Image")) {
	    IV tmp = SvIV((SV*)SvRV(ST(0)));
	    image = INT2PTR(GD__Image,tmp);
	}
	else
	    Perl_croak_nocontext("%s: %s is not of type %s",
			"GD::Image::colorClosest",
			"image", "GD::Image")
;
#line 1850 "GD.xs"
	{
		RETVAL = gdImageColorClosest(image,r,g,b);
	}
#line 3619 "GD.c"
	XSprePUSH; PUSHi((IV)RETVAL);
    }
    XSRETURN(1);
}


XS_EUPXS(XS_GD__Image_colorClosestAlpha); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_GD__Image_colorClosestAlpha)
{
    dVAR; dXSARGS;
    if (items != 5)
       croak_xs_usage(cv,  "image, r, g, b, a");
    {
	GD__Image	image;
	int	r = (int)SvIV(ST(1))
;
	int	g = (int)SvIV(ST(2))
;
	int	b = (int)SvIV(ST(3))
;
	int	a = (int)SvIV(ST(4))
;
	int	RETVAL;
	dXSTARG;

	if (SvROK(ST(0)) && sv_derived_from(ST(0), "GD::Image")) {
	    IV tmp = SvIV((SV*)SvRV(ST(0)));
	    image = INT2PTR(GD__Image,tmp);
	}
	else
	    Perl_croak_nocontext("%s: %s is not of type %s",
			"GD::Image::colorClosestAlpha",
			"image", "GD::Image")
;
#line 1865 "GD.xs"
	{
		RETVAL = gdImageColorClosest(image,r,g,b);
	}
#line 3658 "GD.c"
	XSprePUSH; PUSHi((IV)RETVAL);
    }
    XSRETURN(1);
}


XS_EUPXS(XS_GD__Image_colorClosestHWB); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_GD__Image_colorClosestHWB)
{
    dVAR; dXSARGS;
    if (items != 4)
       croak_xs_usage(cv,  "image, r, g, b");
    {
	GD__Image	image;
	int	r = (int)SvIV(ST(1))
;
	int	g = (int)SvIV(ST(2))
;
	int	b = (int)SvIV(ST(3))
;
	int	RETVAL;
	dXSTARG;

	if (SvROK(ST(0)) && sv_derived_from(ST(0), "GD::Image")) {
	    IV tmp = SvIV((SV*)SvRV(ST(0)));
	    image = INT2PTR(GD__Image,tmp);
	}
	else
	    Perl_croak_nocontext("%s: %s is not of type %s",
			"GD::Image::colorClosestHWB",
			"image", "GD::Image")
;
#line 1879 "GD.xs"
	{
		RETVAL = gdImageColorClosestHWB(image,r,g,b);
	}
#line 3695 "GD.c"
	XSprePUSH; PUSHi((IV)RETVAL);
    }
    XSRETURN(1);
}


XS_EUPXS(XS_GD__Image_colorExact); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_GD__Image_colorExact)
{
    dVAR; dXSARGS;
    if (items != 4)
       croak_xs_usage(cv,  "image, r, g, b");
    {
	GD__Image	image;
	int	r = (int)SvIV(ST(1))
;
	int	g = (int)SvIV(ST(2))
;
	int	b = (int)SvIV(ST(3))
;
	int	RETVAL;
	dXSTARG;

	if (SvROK(ST(0)) && sv_derived_from(ST(0), "GD::Image")) {
	    IV tmp = SvIV((SV*)SvRV(ST(0)));
	    image = INT2PTR(GD__Image,tmp);
	}
	else
	    Perl_croak_nocontext("%s: %s is not of type %s",
			"GD::Image::colorExact",
			"image", "GD::Image")
;
#line 1893 "GD.xs"
	{
		RETVAL = gdImageColorExact(image,r,g,b);
	}
#line 3732 "GD.c"
	XSprePUSH; PUSHi((IV)RETVAL);
    }
    XSRETURN(1);
}


XS_EUPXS(XS_GD__Image_colorExactAlpha); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_GD__Image_colorExactAlpha)
{
    dVAR; dXSARGS;
    if (items != 5)
       croak_xs_usage(cv,  "image, r, g, b, a");
    {
	GD__Image	image;
	int	r = (int)SvIV(ST(1))
;
	int	g = (int)SvIV(ST(2))
;
	int	b = (int)SvIV(ST(3))
;
	int	a = (int)SvIV(ST(4))
;
	int	RETVAL;
	dXSTARG;

	if (SvROK(ST(0)) && sv_derived_from(ST(0), "GD::Image")) {
	    IV tmp = SvIV((SV*)SvRV(ST(0)));
	    image = INT2PTR(GD__Image,tmp);
	}
	else
	    Perl_croak_nocontext("%s: %s is not of type %s",
			"GD::Image::colorExactAlpha",
			"image", "GD::Image")
;
#line 1908 "GD.xs"
	{
		RETVAL = gdImageColorExactAlpha(image,r,g,b,a);
	}
#line 3771 "GD.c"
	XSprePUSH; PUSHi((IV)RETVAL);
    }
    XSRETURN(1);
}


XS_EUPXS(XS_GD__Image_colorResolve); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_GD__Image_colorResolve)
{
    dVAR; dXSARGS;
    if (items != 4)
       croak_xs_usage(cv,  "image, r, g, b");
    {
	GD__Image	image;
	int	r = (int)SvIV(ST(1))
;
	int	g = (int)SvIV(ST(2))
;
	int	b = (int)SvIV(ST(3))
;
	int	RETVAL;
	dXSTARG;

	if (SvROK(ST(0)) && sv_derived_from(ST(0), "GD::Image")) {
	    IV tmp = SvIV((SV*)SvRV(ST(0)));
	    image = INT2PTR(GD__Image,tmp);
	}
	else
	    Perl_croak_nocontext("%s: %s is not of type %s",
			"GD::Image::colorResolve",
			"image", "GD::Image")
;
#line 1922 "GD.xs"
	{
		RETVAL = gdImageColorResolve(image,r,g,b);
	}
#line 3808 "GD.c"
	XSprePUSH; PUSHi((IV)RETVAL);
    }
    XSRETURN(1);
}


XS_EUPXS(XS_GD__Image_colorResolveAlpha); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_GD__Image_colorResolveAlpha)
{
    dVAR; dXSARGS;
    if (items != 5)
       croak_xs_usage(cv,  "image, r, g, b, a");
    {
	GD__Image	image;
	int	r = (int)SvIV(ST(1))
;
	int	g = (int)SvIV(ST(2))
;
	int	b = (int)SvIV(ST(3))
;
	int	a = (int)SvIV(ST(4))
;
	int	RETVAL;
	dXSTARG;

	if (SvROK(ST(0)) && sv_derived_from(ST(0), "GD::Image")) {
	    IV tmp = SvIV((SV*)SvRV(ST(0)));
	    image = INT2PTR(GD__Image,tmp);
	}
	else
	    Perl_croak_nocontext("%s: %s is not of type %s",
			"GD::Image::colorResolveAlpha",
			"image", "GD::Image")
;
#line 1937 "GD.xs"
	{
		RETVAL = gdImageColorResolveAlpha(image,r,g,b,a);
	}
#line 3847 "GD.c"
	XSprePUSH; PUSHi((IV)RETVAL);
    }
    XSRETURN(1);
}


XS_EUPXS(XS_GD__Image_colorsTotal); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_GD__Image_colorsTotal)
{
    dVAR; dXSARGS;
    if (items != 1)
       croak_xs_usage(cv,  "image");
    {
	GD__Image	image;
	int	RETVAL;
	dXSTARG;

	if (SvROK(ST(0)) && sv_derived_from(ST(0), "GD::Image")) {
	    IV tmp = SvIV((SV*)SvRV(ST(0)));
	    image = INT2PTR(GD__Image,tmp);
	}
	else
	    Perl_croak_nocontext("%s: %s is not of type %s",
			"GD::Image::colorsTotal",
			"image", "GD::Image")
;
#line 1948 "GD.xs"
	{
	   if (gdImageTrueColor(image))
 	     XSRETURN_UNDEF;
	   RETVAL = gdImageColorsTotal(image);
	}
#line 3880 "GD.c"
	XSprePUSH; PUSHi((IV)RETVAL);
    }
    XSRETURN(1);
}


XS_EUPXS(XS_GD__Image_interlaced); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_GD__Image_interlaced)
{
    dVAR; dXSARGS;
    if (items < 1)
       croak_xs_usage(cv,  "image, ...");
    {
	GD__Image	image;
	int	RETVAL;
	dXSTARG;

	if (SvROK(ST(0)) && sv_derived_from(ST(0), "GD::Image")) {
	    IV tmp = SvIV((SV*)SvRV(ST(0)));
	    image = INT2PTR(GD__Image,tmp);
	}
	else
	    Perl_croak_nocontext("%s: %s is not of type %s",
			"GD::Image::interlaced",
			"image", "GD::Image")
;
#line 1962 "GD.xs"
	{
	  if (items > 1) {
	    if (SvOK(ST(1)))
	      gdImageInterlace(image,1);
	    else
	      gdImageInterlace(image,0);
	  }
	  RETVAL = gdImageGetInterlaced(image);
	}
#line 3917 "GD.c"
	XSprePUSH; PUSHi((IV)RETVAL);
    }
    XSRETURN(1);
}


XS_EUPXS(XS_GD__Image_compare); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_GD__Image_compare)
{
    dVAR; dXSARGS;
    if (items != 2)
       croak_xs_usage(cv,  "image1, image2");
    {
	GD__Image	image1;
	GD__Image	image2;
	int	RETVAL;
	dXSTARG;

	if (SvROK(ST(0)) && sv_derived_from(ST(0), "GD::Image")) {
	    IV tmp = SvIV((SV*)SvRV(ST(0)));
	    image1 = INT2PTR(GD__Image,tmp);
	}
	else
	    Perl_croak_nocontext("%s: %s is not of type %s",
			"GD::Image::compare",
			"image1", "GD::Image")
;

	if (SvROK(ST(1)) && sv_derived_from(ST(1), "GD::Image")) {
	    IV tmp = SvIV((SV*)SvRV(ST(1)));
	    image2 = INT2PTR(GD__Image,tmp);
	}
	else
	    Perl_croak_nocontext("%s: %s is not of type %s",
			"GD::Image::compare",
			"image2", "GD::Image")
;
#line 1980 "GD.xs"
	{
	  RETVAL = gdImageCompare(image1,image2);
	}
#line 3959 "GD.c"
	XSprePUSH; PUSHi((IV)RETVAL);
    }
    XSRETURN(1);
}


XS_EUPXS(XS_GD__Image_colorDeallocate); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_GD__Image_colorDeallocate)
{
    dVAR; dXSARGS;
    if (items != 2)
       croak_xs_usage(cv,  "image, color");
    {
	GD__Image	image;
	int	color = (int)SvIV(ST(1))
;

	if (SvROK(ST(0)) && sv_derived_from(ST(0), "GD::Image")) {
	    IV tmp = SvIV((SV*)SvRV(ST(0)));
	    image = INT2PTR(GD__Image,tmp);
	}
	else
	    Perl_croak_nocontext("%s: %s is not of type %s",
			"GD::Image::colorDeallocate",
			"image", "GD::Image")
;
#line 1992 "GD.xs"
	{
		gdImageColorDeallocate(image,color);
	}
#line 3990 "GD.c"
    }
    XSRETURN_EMPTY;
}


XS_EUPXS(XS_GD__Image_copy); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_GD__Image_copy)
{
    dVAR; dXSARGS;
    if (items != 8)
       croak_xs_usage(cv,  "destination, source, dstX, dstY, srcX, srcY, w, h");
    {
	GD__Image	destination;
	GD__Image	source;
	int	dstX = (int)SvIV(ST(2))
;
	int	dstY = (int)SvIV(ST(3))
;
	int	srcX = (int)SvIV(ST(4))
;
	int	srcY = (int)SvIV(ST(5))
;
	int	w = (int)SvIV(ST(6))
;
	int	h = (int)SvIV(ST(7))
;

	if (SvROK(ST(0)) && sv_derived_from(ST(0), "GD::Image")) {
	    IV tmp = SvIV((SV*)SvRV(ST(0)));
	    destination = INT2PTR(GD__Image,tmp);
	}
	else
	    Perl_croak_nocontext("%s: %s is not of type %s",
			"GD::Image::copy",
			"destination", "GD::Image")
;

	if (SvROK(ST(1)) && sv_derived_from(ST(1), "GD::Image")) {
	    IV tmp = SvIV((SV*)SvRV(ST(1)));
	    source = INT2PTR(GD__Image,tmp);
	}
	else
	    Perl_croak_nocontext("%s: %s is not of type %s",
			"GD::Image::copy",
			"source", "GD::Image")
;
#line 2008 "GD.xs"
	{
		gdImageCopy(destination,source,dstX,dstY,srcX,srcY,w,h);
	}
#line 4041 "GD.c"
    }
    XSRETURN_EMPTY;
}


XS_EUPXS(XS_GD__Image_copyResized); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_GD__Image_copyResized)
{
    dVAR; dXSARGS;
    if (items != 10)
       croak_xs_usage(cv,  "destination, source, dstX, dstY, srcX, srcY, destW, destH, srcW, srcH");
    {
	GD__Image	destination;
	GD__Image	source;
	int	dstX = (int)SvIV(ST(2))
;
	int	dstY = (int)SvIV(ST(3))
;
	int	srcX = (int)SvIV(ST(4))
;
	int	srcY = (int)SvIV(ST(5))
;
	int	destW = (int)SvIV(ST(6))
;
	int	destH = (int)SvIV(ST(7))
;
	int	srcW = (int)SvIV(ST(8))
;
	int	srcH = (int)SvIV(ST(9))
;

	if (SvROK(ST(0)) && sv_derived_from(ST(0), "GD::Image")) {
	    IV tmp = SvIV((SV*)SvRV(ST(0)));
	    destination = INT2PTR(GD__Image,tmp);
	}
	else
	    Perl_croak_nocontext("%s: %s is not of type %s",
			"GD::Image::copyResized",
			"destination", "GD::Image")
;

	if (SvROK(ST(1)) && sv_derived_from(ST(1), "GD::Image")) {
	    IV tmp = SvIV((SV*)SvRV(ST(1)));
	    source = INT2PTR(GD__Image,tmp);
	}
	else
	    Perl_croak_nocontext("%s: %s is not of type %s",
			"GD::Image::copyResized",
			"source", "GD::Image")
;
#line 2026 "GD.xs"
	{
		gdImageCopyResized(destination,source,dstX,dstY,srcX,srcY,destW,destH,srcW,srcH);
	}
#line 4096 "GD.c"
    }
    XSRETURN_EMPTY;
}


XS_EUPXS(XS_GD__Image_copyResampled); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_GD__Image_copyResampled)
{
    dVAR; dXSARGS;
    if (items != 10)
       croak_xs_usage(cv,  "destination, source, dstX, dstY, srcX, srcY, destW, destH, srcW, srcH");
    {
	GD__Image	destination;
	GD__Image	source;
	int	dstX = (int)SvIV(ST(2))
;
	int	dstY = (int)SvIV(ST(3))
;
	int	srcX = (int)SvIV(ST(4))
;
	int	srcY = (int)SvIV(ST(5))
;
	int	destW = (int)SvIV(ST(6))
;
	int	destH = (int)SvIV(ST(7))
;
	int	srcW = (int)SvIV(ST(8))
;
	int	srcH = (int)SvIV(ST(9))
;

	if (SvROK(ST(0)) && sv_derived_from(ST(0), "GD::Image")) {
	    IV tmp = SvIV((SV*)SvRV(ST(0)));
	    destination = INT2PTR(GD__Image,tmp);
	}
	else
	    Perl_croak_nocontext("%s: %s is not of type %s",
			"GD::Image::copyResampled",
			"destination", "GD::Image")
;

	if (SvROK(ST(1)) && sv_derived_from(ST(1), "GD::Image")) {
	    IV tmp = SvIV((SV*)SvRV(ST(1)));
	    source = INT2PTR(GD__Image,tmp);
	}
	else
	    Perl_croak_nocontext("%s: %s is not of type %s",
			"GD::Image::copyResampled",
			"source", "GD::Image")
;
#line 2044 "GD.xs"
	{
		gdImageCopyResampled(destination,source,dstX,dstY,srcX,srcY,destW,destH,srcW,srcH);
	}
#line 4151 "GD.c"
    }
    XSRETURN_EMPTY;
}


XS_EUPXS(XS_GD__Image_copyMerge); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_GD__Image_copyMerge)
{
    dVAR; dXSARGS;
    if (items != 9)
       croak_xs_usage(cv,  "destination, source, dstX, dstY, srcX, srcY, w, h, pct");
    {
	GD__Image	destination;
	GD__Image	source;
	int	dstX = (int)SvIV(ST(2))
;
	int	dstY = (int)SvIV(ST(3))
;
	int	srcX = (int)SvIV(ST(4))
;
	int	srcY = (int)SvIV(ST(5))
;
	int	w = (int)SvIV(ST(6))
;
	int	h = (int)SvIV(ST(7))
;
	int	pct = (int)SvIV(ST(8))
;

	if (SvROK(ST(0)) && sv_derived_from(ST(0), "GD::Image")) {
	    IV tmp = SvIV((SV*)SvRV(ST(0)));
	    destination = INT2PTR(GD__Image,tmp);
	}
	else
	    Perl_croak_nocontext("%s: %s is not of type %s",
			"GD::Image::copyMerge",
			"destination", "GD::Image")
;

	if (SvROK(ST(1)) && sv_derived_from(ST(1), "GD::Image")) {
	    IV tmp = SvIV((SV*)SvRV(ST(1)));
	    source = INT2PTR(GD__Image,tmp);
	}
	else
	    Perl_croak_nocontext("%s: %s is not of type %s",
			"GD::Image::copyMerge",
			"source", "GD::Image")
;
#line 2061 "GD.xs"
	{
		gdImageCopyMerge(destination,source,dstX,dstY,srcX,srcY,w,h,pct);
	}
#line 4204 "GD.c"
    }
    XSRETURN_EMPTY;
}


XS_EUPXS(XS_GD__Image_copyMergeGray); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_GD__Image_copyMergeGray)
{
    dVAR; dXSARGS;
    if (items != 9)
       croak_xs_usage(cv,  "destination, source, dstX, dstY, srcX, srcY, w, h, pct");
    {
	GD__Image	destination;
	GD__Image	source;
	int	dstX = (int)SvIV(ST(2))
;
	int	dstY = (int)SvIV(ST(3))
;
	int	srcX = (int)SvIV(ST(4))
;
	int	srcY = (int)SvIV(ST(5))
;
	int	w = (int)SvIV(ST(6))
;
	int	h = (int)SvIV(ST(7))
;
	int	pct = (int)SvIV(ST(8))
;

	if (SvROK(ST(0)) && sv_derived_from(ST(0), "GD::Image")) {
	    IV tmp = SvIV((SV*)SvRV(ST(0)));
	    destination = INT2PTR(GD__Image,tmp);
	}
	else
	    Perl_croak_nocontext("%s: %s is not of type %s",
			"GD::Image::copyMergeGray",
			"destination", "GD::Image")
;

	if (SvROK(ST(1)) && sv_derived_from(ST(1), "GD::Image")) {
	    IV tmp = SvIV((SV*)SvRV(ST(1)));
	    source = INT2PTR(GD__Image,tmp);
	}
	else
	    Perl_croak_nocontext("%s: %s is not of type %s",
			"GD::Image::copyMergeGray",
			"source", "GD::Image")
;
#line 2078 "GD.xs"
	{
		gdImageCopyMergeGray(destination,source,dstX,dstY,srcX,srcY,w,h,pct);
	}
#line 4257 "GD.c"
    }
    XSRETURN_EMPTY;
}


XS_EUPXS(XS_GD__Image_paletteCopy); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_GD__Image_paletteCopy)
{
    dVAR; dXSARGS;
    if (items != 2)
       croak_xs_usage(cv,  "destination, source");
    {
	GD__Image	destination;
	GD__Image	source;

	if (SvROK(ST(0)) && sv_derived_from(ST(0), "GD::Image")) {
	    IV tmp = SvIV((SV*)SvRV(ST(0)));
	    destination = INT2PTR(GD__Image,tmp);
	}
	else
	    Perl_croak_nocontext("%s: %s is not of type %s",
			"GD::Image::paletteCopy",
			"destination", "GD::Image")
;

	if (SvROK(ST(1)) && sv_derived_from(ST(1), "GD::Image")) {
	    IV tmp = SvIV((SV*)SvRV(ST(1)));
	    source = INT2PTR(GD__Image,tmp);
	}
	else
	    Perl_croak_nocontext("%s: %s is not of type %s",
			"GD::Image::paletteCopy",
			"source", "GD::Image")
;
#line 2088 "GD.xs"
	{
		gdImagePaletteCopy(destination,source);
	}
#line 4296 "GD.c"
    }
    XSRETURN_EMPTY;
}


XS_EUPXS(XS_GD__Image_char); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_GD__Image_char)
{
    dVAR; dXSARGS;
    if (items != 6)
       croak_xs_usage(cv,  "image, font, x, y, c, color");
    {
	GD__Image	image;
	GD__Font	font;
	int	x = (int)SvIV(ST(2))
;
	int	y = (int)SvIV(ST(3))
;
	char *	c = (char *)SvPV_nolen(ST(4))
;
	int	color = (int)SvIV(ST(5))
;

	if (SvROK(ST(0)) && sv_derived_from(ST(0), "GD::Image")) {
	    IV tmp = SvIV((SV*)SvRV(ST(0)));
	    image = INT2PTR(GD__Image,tmp);
	}
	else
	    Perl_croak_nocontext("%s: %s is not of type %s",
			"GD::Image::char",
			"image", "GD::Image")
;

	if (SvROK(ST(1)) && sv_derived_from(ST(1), "GD::Font")) {
	    IV tmp = SvIV((SV*)SvRV(ST(1)));
	    font = INT2PTR(GD__Font,tmp);
	}
	else
	    Perl_croak_nocontext("%s: %s is not of type %s",
			"GD::Image::char",
			"font", "GD::Font")
;
#line 2102 "GD.xs"
	{
		gdImageChar(image,font,x,y,*c,color);
	}
#line 4343 "GD.c"
    }
    XSRETURN_EMPTY;
}


XS_EUPXS(XS_GD__Image_charUp); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_GD__Image_charUp)
{
    dVAR; dXSARGS;
    if (items != 6)
       croak_xs_usage(cv,  "image, font, x, y, c, color");
    {
	GD__Image	image;
	GD__Font	font;
	int	x = (int)SvIV(ST(2))
;
	int	y = (int)SvIV(ST(3))
;
	char *	c = (char *)SvPV_nolen(ST(4))
;
	int	color = (int)SvIV(ST(5))
;

	if (SvROK(ST(0)) && sv_derived_from(ST(0), "GD::Image")) {
	    IV tmp = SvIV((SV*)SvRV(ST(0)));
	    image = INT2PTR(GD__Image,tmp);
	}
	else
	    Perl_croak_nocontext("%s: %s is not of type %s",
			"GD::Image::charUp",
			"image", "GD::Image")
;

	if (SvROK(ST(1)) && sv_derived_from(ST(1), "GD::Font")) {
	    IV tmp = SvIV((SV*)SvRV(ST(1)));
	    font = INT2PTR(GD__Font,tmp);
	}
	else
	    Perl_croak_nocontext("%s: %s is not of type %s",
			"GD::Image::charUp",
			"font", "GD::Font")
;
#line 2116 "GD.xs"
	{
		gdImageCharUp(image,font,x,y,*c,color);
	}
#line 4390 "GD.c"
    }
    XSRETURN_EMPTY;
}


XS_EUPXS(XS_GD__Image_string); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_GD__Image_string)
{
    dVAR; dXSARGS;
    if (items != 6)
       croak_xs_usage(cv,  "image, font, x, y, s, color");
    {
	GD__Image	image;
	GD__Font	font;
	int	x = (int)SvIV(ST(2))
;
	int	y = (int)SvIV(ST(3))
;
	char *	s = (char *)SvPV_nolen(ST(4))
;
	int	color = (int)SvIV(ST(5))
;

	if (SvROK(ST(0)) && sv_derived_from(ST(0), "GD::Image")) {
	    IV tmp = SvIV((SV*)SvRV(ST(0)));
	    image = INT2PTR(GD__Image,tmp);
	}
	else
	    Perl_croak_nocontext("%s: %s is not of type %s",
			"GD::Image::string",
			"image", "GD::Image")
;

	if (SvROK(ST(1)) && sv_derived_from(ST(1), "GD::Font")) {
	    IV tmp = SvIV((SV*)SvRV(ST(1)));
	    font = INT2PTR(GD__Font,tmp);
	}
	else
	    Perl_croak_nocontext("%s: %s is not of type %s",
			"GD::Image::string",
			"font", "GD::Font")
;
#line 2130 "GD.xs"
	{
		gdImageString(image,font,x,y,(unsigned char*)s,color);
	}
#line 4437 "GD.c"
    }
    XSRETURN_EMPTY;
}


XS_EUPXS(XS_GD__Image_stringUp); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_GD__Image_stringUp)
{
    dVAR; dXSARGS;
    if (items != 6)
       croak_xs_usage(cv,  "image, font, x, y, s, color");
    {
	GD__Image	image;
	GD__Font	font;
	int	x = (int)SvIV(ST(2))
;
	int	y = (int)SvIV(ST(3))
;
	char *	s = (char *)SvPV_nolen(ST(4))
;
	int	color = (int)SvIV(ST(5))
;

	if (SvROK(ST(0)) && sv_derived_from(ST(0), "GD::Image")) {
	    IV tmp = SvIV((SV*)SvRV(ST(0)));
	    image = INT2PTR(GD__Image,tmp);
	}
	else
	    Perl_croak_nocontext("%s: %s is not of type %s",
			"GD::Image::stringUp",
			"image", "GD::Image")
;

	if (SvROK(ST(1)) && sv_derived_from(ST(1), "GD::Font")) {
	    IV tmp = SvIV((SV*)SvRV(ST(1)));
	    font = INT2PTR(GD__Font,tmp);
	}
	else
	    Perl_croak_nocontext("%s: %s is not of type %s",
			"GD::Image::stringUp",
			"font", "GD::Font")
;
#line 2144 "GD.xs"
	{
		gdImageStringUp(image,font,x,y,(unsigned char*)s,color);
	}
#line 4484 "GD.c"
    }
    XSRETURN_EMPTY;
}


XS_EUPXS(XS_GD__Image_stringFT); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_GD__Image_stringFT)
{
    dVAR; dXSARGS;
    if (items < 8)
       croak_xs_usage(cv,  "image, fgcolor, fontname, ptsize, angle, x, y, string, ...");
    PERL_UNUSED_VAR(ax); /* -Wall */
    SP -= items;
    {
	SV *	image = ST(0)
;
	int	fgcolor = (int)SvIV(ST(1))
;
	char *	fontname = (char *)SvPV_nolen(ST(2))
;
	double	ptsize = (double)SvNV(ST(3))
;
	double	angle = (double)SvNV(ST(4))
;
	int	x = (int)SvIV(ST(5))
;
	int	y = (int)SvIV(ST(6))
;
	char *	string = (char *)SvPV_nolen(ST(7))
;
#line 2160 "GD.xs"
	  gdImagePtr img;
	  int        brect[8];
	  char       *err;
          char       *a;
	  SV*        errormsg;
          HV*        hash;
          SV**       value;
	  int        i;
          int        hdpi;
          int        vdpi;
          gdFTStringExtra strex;
#line 4527 "GD.c"
#line 2172 "GD.xs"
	{
#ifndef HAVE_FT
  	errormsg = perl_get_sv("@",0);
	sv_setpv(errormsg,"libgd was not built with FreeType font support\n");
	XSRETURN_EMPTY;
#endif
          if (sv_isobject(image) && sv_derived_from(image, "GD::Image")) {
            IV tmp = SvIV((SV*)SvRV(image));
            img = (gdImagePtr) tmp;
	  } else {
	    img = NULL;
	  }

	  if (items == 9) {  /* hashref options at end */
	    if (SvTYPE(SvRV(ST(8))) != SVt_PVHV)
	      croak ("Usage: $gd->stringFT(image,fgcolor,fontname,ptsize,angle,x,y,string,[{options}])");
	    hash  = (HV*)SvRV(ST(8));
	    strex.flags       = 0;
	    strex.linespacing = 0;
	    strex.charmap     = 0;
	    if (value = hv_fetch(hash,"linespacing",strlen("linespacing"),0)) {
	      strex.flags |= gdFTEX_LINESPACE;
	      strex.linespacing = SvNV(*value);
	    }
	    if (value = hv_fetch(hash,"charmap",strlen("charmap"),0)) {
	      strex.flags |= gdFTEX_CHARMAP;
	      if (strEQ(SvPV_nolen(*value),"Unicode"))
		strex.charmap = gdFTEX_Unicode;
	      else if (strEQ(SvPV_nolen(*value),"Shift_JIS"))
		strex.charmap = gdFTEX_Shift_JIS;
	      else if (strEQ(SvPV_nolen(*value),"Big5"))
		strex.charmap = gdFTEX_Big5;
	      else
		croak("Unknown charmap %s",SvPV_nolen(*value));
	    }
#ifdef VERSION_33
            if (value = hv_fetch(hash,"resolution",strlen("resolution"),0)) {
	      strex.flags |= gdFTEX_RESOLUTION;
	      a = SvPV_nolen(*value);
	      if (sscanf(a,"%d,%d",&hdpi,&vdpi) == 2) {
		strex.hdpi = hdpi;
		strex.vdpi = vdpi;
	      }
	    }
            if (value = hv_fetch(hash,"kerning",strlen("kerning"),0)) {
	      if (!SvTRUE(*value)) {
		strex.flags |= gdFTEX_DISABLE_KERNING;
	      }
              else
                strex.flags &= gdFTEX_DISABLE_KERNING;
	    }
#endif
	    err = gdImageStringFTEx(img,brect,fgcolor,fontname,ptsize,angle,x,y,string,&strex);
	  }

	  else {
	    err = gdImageStringFT(img,brect,fgcolor,fontname,ptsize,angle,x,y,string);
	  }
	  if (err) {
	    errormsg = perl_get_sv("@",0);
	    if (errormsg != NULL)
	      sv_setpv(errormsg,err);
	    XSRETURN_EMPTY;
	  } else {
	    EXTEND(sp,8);
	    for (i=0;i<8;i++) {
	      PUSHs(sv_2mortal(newSViv(brect[i])));
	    }
	  }

	}
#line 4600 "GD.c"
	PUTBACK;
	return;
    }
}


XS_EUPXS(XS_GD__Image_stringFTCircle); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_GD__Image_stringFTCircle)
{
    dVAR; dXSARGS;
    if (items != 11)
       croak_xs_usage(cv,  "image, cx, cy, radius, textRadius, fillPortion, fontname, points, top, bottom, fgcolor");
    {
	GD__Image	image;
	int	cx = (int)SvIV(ST(1))
;
	int	cy = (int)SvIV(ST(2))
;
	double	radius = (double)SvNV(ST(3))
;
	double	textRadius = (double)SvNV(ST(4))
;
	double	fillPortion = (double)SvNV(ST(5))
;
	char *	fontname = (char *)SvPV_nolen(ST(6))
;
	double	points = (double)SvNV(ST(7))
;
	char *	top = (char *)SvPV_nolen(ST(8))
;
	char *	bottom = (char *)SvPV_nolen(ST(9))
;
	int	fgcolor = (int)SvIV(ST(10))
;
#line 2259 "GD.xs"
        char*      err;        
        SV*        errormsg;
#line 4638 "GD.c"
	int	RETVAL;
	dXSTARG;

	if (SvROK(ST(0)) && sv_derived_from(ST(0), "GD::Image")) {
	    IV tmp = SvIV((SV*)SvRV(ST(0)));
	    image = INT2PTR(GD__Image,tmp);
	}
	else
	    Perl_croak_nocontext("%s: %s is not of type %s",
			"GD::Image::stringFTCircle",
			"image", "GD::Image")
;
#line 2262 "GD.xs"
	{
#ifdef HAVE_FT
#ifdef HAVE_FTCIRCLE
	fprintf(stderr,"cx=%d,cy=%d,radius=%f,textRadius=%f,fillPortion=%f,fontname=%s,points=%f,top=%s,bottom=%s,fgcolor=%d",
		cx,cy,radius,textRadius,
		fillPortion,fontname,points,top,bottom,fgcolor);
        err = gdImageStringFTCircle(image,cx,cy,radius,textRadius,
				    fillPortion,fontname,points,top,bottom,fgcolor);
        if (err) {
	    errormsg = perl_get_sv("@",0);
	    if (errormsg != NULL)
	      sv_setpv(errormsg,err);
	    XSRETURN_EMPTY;
	  } else {
            RETVAL = 1;
	  }
#else
  	errormsg = perl_get_sv("@",0);
	sv_setpv(errormsg,"libgd must be version 2.0.33 or higher to use this function\n");
	XSRETURN_EMPTY;
#endif
#else
  	errormsg = perl_get_sv("@",0);
	sv_setpv(errormsg,"libgd was not built with FreeType support\n");
	XSRETURN_EMPTY;
#endif
	}
#line 4679 "GD.c"
	XSprePUSH; PUSHi((IV)RETVAL);
    }
    XSRETURN(1);
}


XS_EUPXS(XS_GD__Image_useFontConfig); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_GD__Image_useFontConfig)
{
    dVAR; dXSARGS;
    if (items != 2)
       croak_xs_usage(cv,  "image, flag");
    {
	SV*	image = ST(0)
;
	int	flag = (int)SvIV(ST(1))
;
#line 2298 "GD.xs"
     SV* errormsg;
#line 4699 "GD.c"
	int	RETVAL;
	dXSTARG;
#line 2300 "GD.xs"
{
#ifdef HAVE_FONTCONFIG
   RETVAL = gdFTUseFontConfig(flag);
#else
   errormsg = perl_get_sv("@",0);
   sv_setpv(errormsg,"libgd was not built with fontconfig support\n");
   XSRETURN_EMPTY;
#endif
}
#line 4712 "GD.c"
	XSprePUSH; PUSHi((IV)RETVAL);
    }
    XSRETURN(1);
}


XS_EUPXS(XS_GD__Image_alphaBlending); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_GD__Image_alphaBlending)
{
    dVAR; dXSARGS;
    if (items != 2)
       croak_xs_usage(cv,  "image, blending");
    {
	GD__Image	image;
	int	blending = (int)SvIV(ST(1))
;

	if (SvROK(ST(0)) && sv_derived_from(ST(0), "GD::Image")) {
	    IV tmp = SvIV((SV*)SvRV(ST(0)));
	    image = INT2PTR(GD__Image,tmp);
	}
	else
	    Perl_croak_nocontext("%s: %s is not of type %s",
			"GD::Image::alphaBlending",
			"image", "GD::Image")
;
#line 2318 "GD.xs"
{
  gdImageAlphaBlending(image,blending);
}
#line 4743 "GD.c"
    }
    XSRETURN_EMPTY;
}


XS_EUPXS(XS_GD__Image_saveAlpha); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_GD__Image_saveAlpha)
{
    dVAR; dXSARGS;
    if (items != 2)
       croak_xs_usage(cv,  "image, saveAlphaArg");
    {
	GD__Image	image;
	int	saveAlphaArg = (int)SvIV(ST(1))
;

	if (SvROK(ST(0)) && sv_derived_from(ST(0), "GD::Image")) {
	    IV tmp = SvIV((SV*)SvRV(ST(0)));
	    image = INT2PTR(GD__Image,tmp);
	}
	else
	    Perl_croak_nocontext("%s: %s is not of type %s",
			"GD::Image::saveAlpha",
			"image", "GD::Image")
;
#line 2328 "GD.xs"
{
  gdImageSaveAlpha(image,saveAlphaArg) ;
}
#line 4773 "GD.c"
    }
    XSRETURN_EMPTY;
}


XS_EUPXS(XS_GD__Image_clip); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_GD__Image_clip)
{
    dVAR; dXSARGS;
    if (items < 1)
       croak_xs_usage(cv,  "image, ...");
    PERL_UNUSED_VAR(ax); /* -Wall */
    SP -= items;
    {
	GD__Image	image;
#line 2337 "GD.xs"
        int		coords[4];
        int             i;
#line 4792 "GD.c"

	if (SvROK(ST(0)) && sv_derived_from(ST(0), "GD::Image")) {
	    IV tmp = SvIV((SV*)SvRV(ST(0)));
	    image = INT2PTR(GD__Image,tmp);
	}
	else
	    Perl_croak_nocontext("%s: %s is not of type %s",
			"GD::Image::clip",
			"image", "GD::Image")
;
#line 2340 "GD.xs"
	{
	  if (items == 5) {
	    for (i=0;i<4;i++)
	      coords[i] = (int)SvIV(ST(i+1));
	    gdImageSetClip(image,coords[0],coords[1],coords[2],coords[3]);
	  }
	  else if (items > 1) /* something weird */
	    croak("Usage: $gd->clip() or $gd->clip(x1,x2,y1,y2)");

	  gdImageGetClip(image,&coords[0],&coords[1],&coords[2],&coords[3]);
	  EXTEND(sp,4);
	  for (i=0;i<4;i++)
	    PUSHs(sv_2mortal(newSViv(coords[i])));
	}
#line 4818 "GD.c"
	PUTBACK;
	return;
    }
}


XS_EUPXS(XS_GD__Image_setAntiAliased); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_GD__Image_setAntiAliased)
{
    dVAR; dXSARGS;
    if (items != 2)
       croak_xs_usage(cv,  "image, color");
    {
	GD__Image	image;
	int	color = (int)SvIV(ST(1))
;

	if (SvROK(ST(0)) && sv_derived_from(ST(0), "GD::Image")) {
	    IV tmp = SvIV((SV*)SvRV(ST(0)));
	    image = INT2PTR(GD__Image,tmp);
	}
	else
	    Perl_croak_nocontext("%s: %s is not of type %s",
			"GD::Image::setAntiAliased",
			"image", "GD::Image")
;
#line 2361 "GD.xs"
{
  gdImageSetAntiAliased(image,color);
}
#line 4849 "GD.c"
    }
    XSRETURN_EMPTY;
}


XS_EUPXS(XS_GD__Image_setAntiAliasedDontBlend); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_GD__Image_setAntiAliasedDontBlend)
{
    dVAR; dXSARGS;
    if (items < 2 || items > 3)
       croak_xs_usage(cv,  "image, color, flag=1");
    {
	GD__Image	image;
	int	color = (int)SvIV(ST(1))
;
	int	flag;

	if (SvROK(ST(0)) && sv_derived_from(ST(0), "GD::Image")) {
	    IV tmp = SvIV((SV*)SvRV(ST(0)));
	    image = INT2PTR(GD__Image,tmp);
	}
	else
	    Perl_croak_nocontext("%s: %s is not of type %s",
			"GD::Image::setAntiAliasedDontBlend",
			"image", "GD::Image")
;

	if (items < 3)
	    flag = 1;
	else {
	    flag = (int)SvIV(ST(2))
;
	}
#line 2373 "GD.xs"
{
  gdImageSetAntiAliasedDontBlend(image,color,flag);
}
#line 4887 "GD.c"
    }
    XSRETURN_EMPTY;
}


XS_EUPXS(XS_GD__Font_load); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_GD__Font_load)
{
    dVAR; dXSARGS;
    if (items < 1 || items > 2)
       croak_xs_usage(cv,  "packname=\"GD::Font\", fontpath");
    {
	char *	packname;
	char *	fontpath = (char *)SvPV_nolen(ST(1))
;
#line 2386 "GD.xs"
       int             fontfile;
       int             datasize;
       SV*             errormsg;
       char            errstr[256];
       gdFontPtr       font;
       unsigned char   word[4];
       char*           fontdata;
#line 4911 "GD.c"
	GD__Font	RETVAL;

	if (items < 1)
	    packname = "GD::Font";
	else {
	    packname = (char *)SvPV_nolen(ST(0))
;
	}
#line 2394 "GD.xs"
     {
       fontfile = open(fontpath,O_RDONLY);
       if (fontfile < 0) {
         errormsg = perl_get_sv("@",0);
	 snprintf(errstr,256,"could not open font file %s: %s",fontpath,strerror(errno));
         sv_setpv(errormsg,errstr);
 	 XSRETURN_EMPTY;
       }
       font = (gdFontPtr)safemalloc(sizeof(gdFont));
       if (font == NULL)
	 croak("safemalloc() returned NULL while trying to allocate font struct.\n");
       /* read header from font - note that the file is assumed to be littleendian*/
       if (read(fontfile,word,4) < 4)
	 croak("error while reading font file: %s",strerror(errno));
       font->nchars = littleendian(word);

       if (read(fontfile,word,4) < 4)
	 croak("error while reading font file: %s",strerror(errno));
       font->offset = littleendian(word);

       if (read(fontfile,word,4) < 4)
	 croak("error while reading font file: %s",strerror(errno));
       font->w = littleendian(word);

       if (read(fontfile,word,4) < 4)
	 croak("error while reading font file: %s",strerror(errno));
       font->h = littleendian(word);

       datasize = font->nchars * font->w * font->h;
       fontdata = (char*)safemalloc(datasize);
       if (fontdata == NULL)
	 croak("safemalloc() returned NULL while trying to allocate font bitmap.\n");

       if (read(fontfile,fontdata,datasize) < datasize)
	 croak("error while reading font file: %s",strerror(errno));

       font->data = fontdata;

       close(fontfile); /* please don't leak file descriptors! */
       RETVAL = font;
     }
#line 4962 "GD.c"
	{
	    SV * RETVALSV;
	    RETVALSV = sv_newmortal();
	    sv_setref_pv(RETVALSV, "GD::Font", (void*)RETVAL);
	    ST(0) = RETVALSV;
	}
    }
    XSRETURN(1);
}


XS_EUPXS(XS_GD__Font_DESTROY); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_GD__Font_DESTROY)
{
    dVAR; dXSARGS;
    if (items != 1)
       croak_xs_usage(cv,  "self");
    {
	GD__Font	self;

	if (SvROK(ST(0))) {
	    IV tmp = SvIV((SV*)SvRV(ST(0)));
	    self = INT2PTR(GD__Font,tmp);
	}
	else
	    Perl_croak_nocontext("%s: %s is not a reference",
			"GD::Font::DESTROY",
			"self")
;
#line 2443 "GD.xs"
     {
       if (self == gdFontGetSmall()      ||
	   self == gdFontGetLarge()      ||
	   self == gdFontGetGiant()      ||
	   self == gdFontGetMediumBold() ||
	   self == gdFontGetTiny() )
	 XSRETURN_EMPTY;
       safefree(self->data);
       safefree(self);
     }
#line 5003 "GD.c"
    }
    XSRETURN_EMPTY;
}


XS_EUPXS(XS_GD__Font_Small); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_GD__Font_Small)
{
    dVAR; dXSARGS;
    if (items < 0 || items > 1)
       croak_xs_usage(cv,  "packname=\"GD::Font\"");
    {
	char *	packname;
	GD__Font	RETVAL;

	if (items < 1)
	    packname = "GD::Font";
	else {
	    packname = (char *)SvPV_nolen(ST(0))
;
	}
#line 2459 "GD.xs"
	{
		RETVAL = gdFontGetSmall();
	}
#line 5029 "GD.c"
	{
	    SV * RETVALSV;
	    RETVALSV = sv_newmortal();
	    sv_setref_pv(RETVALSV, "GD::Font", (void*)RETVAL);
	    ST(0) = RETVALSV;
	}
    }
    XSRETURN(1);
}


XS_EUPXS(XS_GD__Font_Large); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_GD__Font_Large)
{
    dVAR; dXSARGS;
    if (items < 0 || items > 1)
       croak_xs_usage(cv,  "packname=\"GD::Font\"");
    {
	char *	packname;
	GD__Font	RETVAL;

	if (items < 1)
	    packname = "GD::Font";
	else {
	    packname = (char *)SvPV_nolen(ST(0))
;
	}
#line 2470 "GD.xs"
	{
		RETVAL = gdFontGetLarge();
	}
#line 5061 "GD.c"
	{
	    SV * RETVALSV;
	    RETVALSV = sv_newmortal();
	    sv_setref_pv(RETVALSV, "GD::Font", (void*)RETVAL);
	    ST(0) = RETVALSV;
	}
    }
    XSRETURN(1);
}


XS_EUPXS(XS_GD__Font_Giant); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_GD__Font_Giant)
{
    dVAR; dXSARGS;
    if (items < 0 || items > 1)
       croak_xs_usage(cv,  "packname=\"GD::Font\"");
    {
	char *	packname;
	GD__Font	RETVAL;

	if (items < 1)
	    packname = "GD::Font";
	else {
	    packname = (char *)SvPV_nolen(ST(0))
;
	}
#line 2481 "GD.xs"
	{
		RETVAL = gdFontGetGiant();
	}
#line 5093 "GD.c"
	{
	    SV * RETVALSV;
	    RETVALSV = sv_newmortal();
	    sv_setref_pv(RETVALSV, "GD::Font", (void*)RETVAL);
	    ST(0) = RETVALSV;
	}
    }
    XSRETURN(1);
}


XS_EUPXS(XS_GD__Font_MediumBold); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_GD__Font_MediumBold)
{
    dVAR; dXSARGS;
    if (items < 0 || items > 1)
       croak_xs_usage(cv,  "packname=\"GD::Font\"");
    {
	char *	packname;
	GD__Font	RETVAL;

	if (items < 1)
	    packname = "GD::Font";
	else {
	    packname = (char *)SvPV_nolen(ST(0))
;
	}
#line 2492 "GD.xs"
	{
		RETVAL = gdFontGetMediumBold();
	}
#line 5125 "GD.c"
	{
	    SV * RETVALSV;
	    RETVALSV = sv_newmortal();
	    sv_setref_pv(RETVALSV, "GD::Font", (void*)RETVAL);
	    ST(0) = RETVALSV;
	}
    }
    XSRETURN(1);
}


XS_EUPXS(XS_GD__Font_Tiny); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_GD__Font_Tiny)
{
    dVAR; dXSARGS;
    if (items < 0 || items > 1)
       croak_xs_usage(cv,  "packname=\"GD::Font\"");
    {
	char *	packname;
	GD__Font	RETVAL;

	if (items < 1)
	    packname = "GD::Font";
	else {
	    packname = (char *)SvPV_nolen(ST(0))
;
	}
#line 2503 "GD.xs"
	{
		RETVAL = gdFontGetTiny();
	}
#line 5157 "GD.c"
	{
	    SV * RETVALSV;
	    RETVALSV = sv_newmortal();
	    sv_setref_pv(RETVALSV, "GD::Font", (void*)RETVAL);
	    ST(0) = RETVALSV;
	}
    }
    XSRETURN(1);
}


XS_EUPXS(XS_GD__Font_nchars); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_GD__Font_nchars)
{
    dVAR; dXSARGS;
    if (items != 1)
       croak_xs_usage(cv,  "font");
    {
	GD__Font	font;
	int	RETVAL;
	dXSTARG;

	if (SvROK(ST(0)) && sv_derived_from(ST(0), "GD::Font")) {
	    IV tmp = SvIV((SV*)SvRV(ST(0)));
	    font = INT2PTR(GD__Font,tmp);
	}
	else
	    Perl_croak_nocontext("%s: %s is not of type %s",
			"GD::Font::nchars",
			"font", "GD::Font")
;
#line 2514 "GD.xs"
	{
		RETVAL = font->nchars;
	}
#line 5193 "GD.c"
	XSprePUSH; PUSHi((IV)RETVAL);
    }
    XSRETURN(1);
}


XS_EUPXS(XS_GD__Font_offset); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_GD__Font_offset)
{
    dVAR; dXSARGS;
    if (items != 1)
       croak_xs_usage(cv,  "font");
    {
	GD__Font	font;
	int	RETVAL;
	dXSTARG;

	if (SvROK(ST(0)) && sv_derived_from(ST(0), "GD::Font")) {
	    IV tmp = SvIV((SV*)SvRV(ST(0)));
	    font = INT2PTR(GD__Font,tmp);
	}
	else
	    Perl_croak_nocontext("%s: %s is not of type %s",
			"GD::Font::offset",
			"font", "GD::Font")
;
#line 2525 "GD.xs"
	{
		RETVAL = font->offset;
	}
#line 5224 "GD.c"
	XSprePUSH; PUSHi((IV)RETVAL);
    }
    XSRETURN(1);
}


XS_EUPXS(XS_GD__Font_width); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_GD__Font_width)
{
    dVAR; dXSARGS;
    if (items != 1)
       croak_xs_usage(cv,  "font");
    {
	GD__Font	font;
	int	RETVAL;
	dXSTARG;

	if (SvROK(ST(0)) && sv_derived_from(ST(0), "GD::Font")) {
	    IV tmp = SvIV((SV*)SvRV(ST(0)));
	    font = INT2PTR(GD__Font,tmp);
	}
	else
	    Perl_croak_nocontext("%s: %s is not of type %s",
			"GD::Font::width",
			"font", "GD::Font")
;
#line 2536 "GD.xs"
	{
		RETVAL = font->w;
	}
#line 5255 "GD.c"
	XSprePUSH; PUSHi((IV)RETVAL);
    }
    XSRETURN(1);
}


XS_EUPXS(XS_GD__Font_height); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_GD__Font_height)
{
    dVAR; dXSARGS;
    if (items != 1)
       croak_xs_usage(cv,  "font");
    {
	GD__Font	font;
	int	RETVAL;
	dXSTARG;

	if (SvROK(ST(0)) && sv_derived_from(ST(0), "GD::Font")) {
	    IV tmp = SvIV((SV*)SvRV(ST(0)));
	    font = INT2PTR(GD__Font,tmp);
	}
	else
	    Perl_croak_nocontext("%s: %s is not of type %s",
			"GD::Font::height",
			"font", "GD::Font")
;
#line 2547 "GD.xs"
	{
		RETVAL = font->h;
	}
#line 5286 "GD.c"
	XSprePUSH; PUSHi((IV)RETVAL);
    }
    XSRETURN(1);
}

#ifdef __cplusplus
extern "C"
#endif
XS_EXTERNAL(boot_GD); /* prototype to pass -Wmissing-prototypes */
XS_EXTERNAL(boot_GD)
{
#if PERL_VERSION_LE(5, 21, 5)
    dVAR; dXSARGS;
#else
    dVAR; dXSBOOTARGSXSAPIVERCHK;
#endif
#if (PERL_REVISION == 5 && PERL_VERSION < 9)
    char* file = __FILE__;
#else
    const char* file = __FILE__;
#endif

    PERL_UNUSED_VAR(file);

    PERL_UNUSED_VAR(cv); /* -W */
    PERL_UNUSED_VAR(items); /* -W */
#if PERL_VERSION_LE(5, 21, 5)
    XS_VERSION_BOOTCHECK;
#  ifdef XS_APIVERSION_BOOTCHECK
    XS_APIVERSION_BOOTCHECK;
#  endif
#endif

        newXS_deffile("GD::constant", XS_GD_constant);
        (void)newXSproto_portable("GD::Image::trueColor", XS_GD__Image_trueColor, file, "$$");
        (void)newXSproto_portable("GD::Image::_new", XS_GD__Image__new, file, "$;$$$");
#if XSubPPtmpAAAA
        (void)newXSproto_portable("GD::Image::_newFromPng", XS_GD__Image__newFromPng, file, "$$;$");
        (void)newXSproto_portable("GD::Image::newFromPngData", XS_GD__Image_newFromPngData, file, "$$;$");
#endif
        (void)newXSproto_portable("GD::Image::newFromGdData", XS_GD__Image_newFromGdData, file, "$$");
        (void)newXSproto_portable("GD::Image::newFromGd2Data", XS_GD__Image_newFromGd2Data, file, "$$");
#if XSubPPtmpAAAB
        (void)newXSproto_portable("GD::Image::newFromJpegData", XS_GD__Image_newFromJpegData, file, "$$;$");
#endif
        (void)newXSproto_portable("GD::Image::newFromWBMPData", XS_GD__Image_newFromWBMPData, file, "$$;$");
        (void)newXSproto_portable("GD::Image::_newFromXbm", XS_GD__Image__newFromXbm, file, "$$");
        (void)newXSproto_portable("GD::Image::_newFromGd", XS_GD__Image__newFromGd, file, "$$");
        (void)newXSproto_portable("GD::Image::_newFromGd2", XS_GD__Image__newFromGd2, file, "$$");
#if XSubPPtmpAAAC
        (void)newXSproto_portable("GD::Image::_newFromJpeg", XS_GD__Image__newFromJpeg, file, "$$;$");
#endif
        (void)newXSproto_portable("GD::Image::_newFromWBMP", XS_GD__Image__newFromWBMP, file, "$$");
        (void)newXSproto_portable("GD::Image::newFromXpm", XS_GD__Image_newFromXpm, file, "$$");
        (void)newXSproto_portable("GD::Image::_newFromGd2Part", XS_GD__Image__newFromGd2Part, file, "$$$$$$");
#if XSubPPtmpAAAD
        (void)newXSproto_portable("GD::Image::_newFromGif", XS_GD__Image__newFromGif, file, "$$;$");
        (void)newXSproto_portable("GD::Image::newFromGifData", XS_GD__Image_newFromGifData, file, "$$;$");
#endif
        (void)newXSproto_portable("GD::Image::DESTROY", XS_GD__Image_DESTROY, file, "$");
        (void)newXSproto_portable("GD::Image::STORABLE_freeze", XS_GD__Image_STORABLE_freeze, file, "$$");
        newXS_deffile("GD::Image::STORABLE_thaw", XS_GD__Image_STORABLE_thaw);
#if XSubPPtmpAAAE
        (void)newXSproto_portable("GD::Image::png", XS_GD__Image_png, file, "$;$");
#endif
#if XSubPPtmpAAAF
        (void)newXSproto_portable("GD::Image::jpeg", XS_GD__Image_jpeg, file, "$");
#endif
        (void)newXSproto_portable("GD::Image::gifanimbegin", XS_GD__Image_gifanimbegin, file, "$$$");
        (void)newXSproto_portable("GD::Image::gifanimadd", XS_GD__Image_gifanimadd, file, "$$$$$$$");
        (void)newXSproto_portable("GD::Image::gifanimend", XS_GD__Image_gifanimend, file, "$");
        (void)newXSproto_portable("GD::Image::wbmp", XS_GD__Image_wbmp, file, "$");
#if XSubPPtmpAAAG
        (void)newXSproto_portable("GD::Image::gif", XS_GD__Image_gif, file, "$");
#endif
        (void)newXSproto_portable("GD::Image::gd", XS_GD__Image_gd, file, "$");
        (void)newXSproto_portable("GD::Image::gd2", XS_GD__Image_gd2, file, "$");
        (void)newXSproto_portable("GD::Image::transparent", XS_GD__Image_transparent, file, "$;$");
        (void)newXSproto_portable("GD::Image::getBounds", XS_GD__Image_getBounds, file, "$");
        (void)newXSproto_portable("GD::Image::isTrueColor", XS_GD__Image_isTrueColor, file, "$");
        (void)newXSproto_portable("GD::Image::trueColorToPalette", XS_GD__Image_trueColorToPalette, file, "$;$$");
        (void)newXSproto_portable("GD::Image::rgb", XS_GD__Image_rgb, file, "$$");
        (void)newXSproto_portable("GD::Image::boundsSafe", XS_GD__Image_boundsSafe, file, "$$$");
        (void)newXSproto_portable("GD::Image::getPixel", XS_GD__Image_getPixel, file, "$$$");
        (void)newXSproto_portable("GD::Image::setPixel", XS_GD__Image_setPixel, file, "$$$$");
        (void)newXSproto_portable("GD::Image::copyRotate90", XS_GD__Image_copyRotate90, file, "$");
        (void)newXSproto_portable("GD::Image::copyRotate180", XS_GD__Image_copyRotate180, file, "$");
        (void)newXSproto_portable("GD::Image::copyRotate270", XS_GD__Image_copyRotate270, file, "$");
        (void)newXSproto_portable("GD::Image::copyFlipHorizontal", XS_GD__Image_copyFlipHorizontal, file, "$");
        (void)newXSproto_portable("GD::Image::copyFlipVertical", XS_GD__Image_copyFlipVertical, file, "$");
        (void)newXSproto_portable("GD::Image::copyTranspose", XS_GD__Image_copyTranspose, file, "$");
        (void)newXSproto_portable("GD::Image::copyReverseTranspose", XS_GD__Image_copyReverseTranspose, file, "$");
        (void)newXSproto_portable("GD::Image::rotate180", XS_GD__Image_rotate180, file, "$");
        (void)newXSproto_portable("GD::Image::copyRotated", XS_GD__Image_copyRotated, file, "$$$$$$$$$");
        (void)newXSproto_portable("GD::Image::flipHorizontal", XS_GD__Image_flipHorizontal, file, "$");
        (void)newXSproto_portable("GD::Image::flipVertical", XS_GD__Image_flipVertical, file, "$");
        (void)newXSproto_portable("GD::Image::line", XS_GD__Image_line, file, "$$$$$$");
        (void)newXSproto_portable("GD::Image::dashedLine", XS_GD__Image_dashedLine, file, "$$$$$$");
        (void)newXSproto_portable("GD::Image::openPolygon", XS_GD__Image_openPolygon, file, "$$$");
        (void)newXSproto_portable("GD::Image::unclosedPolygon", XS_GD__Image_unclosedPolygon, file, "$$$");
        (void)newXSproto_portable("GD::Image::filledPolygon", XS_GD__Image_filledPolygon, file, "$$$");
        (void)newXSproto_portable("GD::Image::rectangle", XS_GD__Image_rectangle, file, "$$$$$$");
        (void)newXSproto_portable("GD::Image::filledRectangle", XS_GD__Image_filledRectangle, file, "$$$$$$");
        (void)newXSproto_portable("GD::Image::filledEllipse", XS_GD__Image_filledEllipse, file, "$$$$$$");
        (void)newXSproto_portable("GD::Image::arc", XS_GD__Image_arc, file, "$$$$$$$$");
        (void)newXSproto_portable("GD::Image::filledArc", XS_GD__Image_filledArc, file, "$$$$$$$$$");
        (void)newXSproto_portable("GD::Image::fillToBorder", XS_GD__Image_fillToBorder, file, "$$$$$");
        (void)newXSproto_portable("GD::Image::fill", XS_GD__Image_fill, file, "$$$$");
        (void)newXSproto_portable("GD::Image::setBrush", XS_GD__Image_setBrush, file, "$$");
        (void)newXSproto_portable("GD::Image::setTile", XS_GD__Image_setTile, file, "$$");
        (void)newXSproto_portable("GD::Image::setThickness", XS_GD__Image_setThickness, file, "$$");
        (void)newXSproto_portable("GD::Image::setStyle", XS_GD__Image_setStyle, file, "$;$");
        (void)newXSproto_portable("GD::Image::colorAllocate", XS_GD__Image_colorAllocate, file, "$$$$");
        (void)newXSproto_portable("GD::Image::colorAllocateAlpha", XS_GD__Image_colorAllocateAlpha, file, "$$$$");
        (void)newXSproto_portable("GD::Image::colorClosest", XS_GD__Image_colorClosest, file, "$$$$");
        (void)newXSproto_portable("GD::Image::colorClosestAlpha", XS_GD__Image_colorClosestAlpha, file, "$$$$");
        (void)newXSproto_portable("GD::Image::colorClosestHWB", XS_GD__Image_colorClosestHWB, file, "$$$$");
        (void)newXSproto_portable("GD::Image::colorExact", XS_GD__Image_colorExact, file, "$$$$");
        (void)newXSproto_portable("GD::Image::colorExactAlpha", XS_GD__Image_colorExactAlpha, file, "$$$$");
        (void)newXSproto_portable("GD::Image::colorResolve", XS_GD__Image_colorResolve, file, "$$$$");
        (void)newXSproto_portable("GD::Image::colorResolveAlpha", XS_GD__Image_colorResolveAlpha, file, "$$$$");
        (void)newXSproto_portable("GD::Image::colorsTotal", XS_GD__Image_colorsTotal, file, "$");
        (void)newXSproto_portable("GD::Image::interlaced", XS_GD__Image_interlaced, file, "$;$");
        (void)newXSproto_portable("GD::Image::compare", XS_GD__Image_compare, file, "$$");
        (void)newXSproto_portable("GD::Image::colorDeallocate", XS_GD__Image_colorDeallocate, file, "$$");
        (void)newXSproto_portable("GD::Image::copy", XS_GD__Image_copy, file, "$$$$$$$$");
        (void)newXSproto_portable("GD::Image::copyResized", XS_GD__Image_copyResized, file, "$$$$$$$$$$");
        (void)newXSproto_portable("GD::Image::copyResampled", XS_GD__Image_copyResampled, file, "$$$$$$$$$$");
        (void)newXSproto_portable("GD::Image::copyMerge", XS_GD__Image_copyMerge, file, "$$$$$$$$$");
        (void)newXSproto_portable("GD::Image::copyMergeGray", XS_GD__Image_copyMergeGray, file, "$$$$$$$$$");
        (void)newXSproto_portable("GD::Image::paletteCopy", XS_GD__Image_paletteCopy, file, "$$");
        (void)newXSproto_portable("GD::Image::char", XS_GD__Image_char, file, "$$$$$$");
        (void)newXSproto_portable("GD::Image::charUp", XS_GD__Image_charUp, file, "$$$$$$");
        (void)newXSproto_portable("GD::Image::string", XS_GD__Image_string, file, "$$$$$$");
        (void)newXSproto_portable("GD::Image::stringUp", XS_GD__Image_stringUp, file, "$$$$$$");
        (void)newXSproto_portable("GD::Image::stringFT", XS_GD__Image_stringFT, file, "$$$$$$$$;$");
        (void)newXSproto_portable("GD::Image::stringFTCircle", XS_GD__Image_stringFTCircle, file, "$$$$$$$$$$$");
        (void)newXSproto_portable("GD::Image::useFontConfig", XS_GD__Image_useFontConfig, file, "$$");
        (void)newXSproto_portable("GD::Image::alphaBlending", XS_GD__Image_alphaBlending, file, "$$");
        (void)newXSproto_portable("GD::Image::saveAlpha", XS_GD__Image_saveAlpha, file, "$$");
        (void)newXSproto_portable("GD::Image::clip", XS_GD__Image_clip, file, "$;$$$$");
        (void)newXSproto_portable("GD::Image::setAntiAliased", XS_GD__Image_setAntiAliased, file, "$$");
        (void)newXSproto_portable("GD::Image::setAntiAliasedDontBlend", XS_GD__Image_setAntiAliasedDontBlend, file, "$$$");
        (void)newXSproto_portable("GD::Font::load", XS_GD__Font_load, file, "$$");
        (void)newXSproto_portable("GD::Font::DESTROY", XS_GD__Font_DESTROY, file, "$");
        (void)newXSproto_portable("GD::Font::Small", XS_GD__Font_Small, file, "$");
        (void)newXSproto_portable("GD::Font::Large", XS_GD__Font_Large, file, "$");
        (void)newXSproto_portable("GD::Font::Giant", XS_GD__Font_Giant, file, "$");
        (void)newXSproto_portable("GD::Font::MediumBold", XS_GD__Font_MediumBold, file, "$");
        (void)newXSproto_portable("GD::Font::Tiny", XS_GD__Font_Tiny, file, "$");
        (void)newXSproto_portable("GD::Font::nchars", XS_GD__Font_nchars, file, "$");
        (void)newXSproto_portable("GD::Font::offset", XS_GD__Font_offset, file, "$");
        (void)newXSproto_portable("GD::Font::width", XS_GD__Font_width, file, "$");
        (void)newXSproto_portable("GD::Font::height", XS_GD__Font_height, file, "$");

    /* Initialisation Section */

#line 543 "GD.xs"
{
#ifdef START_MY_CXT
   MY_CXT_INIT;
   MY_CXT.truecolor_default = 0;
#endif
}

#if XSubPPtmpAAAA
#endif
#if XSubPPtmpAAAB
#endif
#if XSubPPtmpAAAC
#endif
#if XSubPPtmpAAAD
#endif
#if XSubPPtmpAAAE
#endif
#if XSubPPtmpAAAF
#endif
#if XSubPPtmpAAAG
#endif
#line 5466 "GD.c"

    /* End of Initialisation Section */

#if PERL_VERSION_LE(5, 21, 5)
#  if PERL_VERSION_GE(5, 9, 0)
    if (PL_unitcheckav)
        call_list(PL_scopestack_ix, PL_unitcheckav);
#  endif
    XSRETURN_YES;
#else
    Perl_xs_boot_epilog(aTHX_ ax);
#endif
}

